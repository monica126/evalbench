[
  {
    "db_id": "card_games",
    "question_id": 340,
    "difficulty": "simple",
    "question": "Which are the cards that have incredibly powerful foils.",
    "evidence": "poweful foils refers to cardKingdomFoilId = cardKingdomId AND cardKingdomId is not null",
    "SQLite_query": "SELECT id FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL",
    "Postgres_query": "SELECT \"id\" FROM \"cards\" WHERE \"cardKingdomFoilId\" IS NOT NULL AND \"cardKingdomId\" IS NOT NULL",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 341,
    "difficulty": "simple",
    "question": "What are the borderless cards available without powerful foils?",
    "evidence": "borderless' refers to borderColor; poweful foils refers to cardKingdomFoilId paired with cardKingdomId AND cardKingdomId is not null",
    "SQLite_query": "SELECT id FROM cards WHERE borderColor = 'borderless' AND (cardKingdomId IS NULL OR cardKingdomId IS NULL)",
    "Postgres_query": "SELECT \"id\" FROM \"cards\" WHERE \"borderColor\" = 'borderless' AND (\"cardKingdomId\" IS NULL OR \"cardKingdomId\" IS NULL)",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 342,
    "difficulty": "simple",
    "question": "List the card names with value that cost more converted mana for the face.",
    "evidence": "more converted mana for the face refers to Max(faceConvertedManaCost);",
    "SQLite_query": "SELECT name FROM cards ORDER BY faceConvertedManaCost LIMIT 1",
    "Postgres_query": "SELECT \"name\" FROM \"cards\" ORDER BY \"faceConvertedManaCost\" ASC NULLS LAST LIMIT 1",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 343,
    "difficulty": "simple",
    "question": "Name all cards with 2015 frame style ranking below 100 on EDHRec.",
    "evidence": "below 100 on EDHRec refers to EDHRec <100; with 2015 frame style refers to frameVersion = 2015;",
    "SQLite_query": "SELECT id FROM cards WHERE edhrecRank < 100 AND frameVersion = 2015",
    "Postgres_query": "SELECT \"id\" FROM \"cards\" WHERE \"edhrecRank\" < 100 AND \"frameVersion\" = 2015",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 344,
    "difficulty": "moderate",
    "question": "List all the mythic rarity print cards banned in gladiator format.",
    "evidence": "mythic rarity printing refers to rarity = 'mythic'; card banned refers to status = 'Banned'; in gladiator format refers to format = 'gladiator';",
    "SQLite_query": "SELECT DISTINCT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'gladiator' AND T2.status = 'Banned' AND T1.rarity = 'mythic'",
    "Postgres_query": "SELECT DISTINCT \"T1\".\"id\" FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T2\".\"format\" = 'gladiator' AND \"T2\".\"status\" = 'Banned' AND \"T1\".\"rarity\" = 'mythic'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 345,
    "difficulty": "moderate",
    "question": "For artifact type of cards that do not have multiple faces on the same card, state its legalities for vintage play format.",
    "evidence": "Artifact type of cards refers to types = 'Artifact'; card does not have multiple faces on the same card refers to side is NULL'; vintage play format refers to format = 'vintage';",
    "SQLite_query": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.type = 'Artifact' AND T2.format = 'vintage' AND T1.side IS NULL",
    "Postgres_query": "SELECT DISTINCT \"T2\".\"status\" FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"type\" = 'Artifact' AND \"T2\".\"format\" = 'vintage' AND \"T1\".\"side\" IS NULL",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 346,
    "difficulty": "moderate",
    "question": "List all the card id and artist with unknown power which are legal for commander play format.",
    "evidence": "unknown power refers to power = '*' or POWER IS NULL; commander play format refers to format = 'commander'; legal for commander play format refers to format = 'commander' where status = 'Legal'",
    "SQLite_query": "SELECT T1.id, T1.artist FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Legal' AND T2.format = 'commander' AND (T1.power IS NULL OR T1.power = '*')",
    "Postgres_query": "SELECT \"T1\".\"id\", \"T1\".\"artist\" FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T2\".\"status\" = 'Legal' AND \"T2\".\"format\" = 'commander' AND (\"T1\".\"power\" IS NULL OR \"T1\".\"power\" = '*')",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 347,
    "difficulty": "moderate",
    "question": "Find all cards illustrated by Stephen Daniel and describe the text of the ruling of these cards. State if these cards have missing or degraded properties and values.",
    "evidence": "cards have missing or degraded properties and value refers to hasContentWarning = 1; 'Stephen Daniele' is artist;",
    "SQLite_query": "SELECT T1.id, T2.text, T1.hasContentWarning FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Stephen Daniele'",
    "Postgres_query": "SELECT \"T1\".\"id\", \"T2\".\"text\", \"T1\".\"hasContentWarning\" FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"artist\" = 'Stephen Daniele'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 348,
    "difficulty": "simple",
    "question": "Describe the information about rulings for card named 'Sublime Epiphany' with number 74s.",
    "evidence": "Sublime Epiphany' is name of cards; number 74s refers to number = '74s'; information refers to text;",
    "SQLite_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Sublime Epiphany' AND T1.number = '74s'",
    "Postgres_query": "SELECT \"T2\".\"text\" FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"name\" = 'Sublime Epiphany' AND \"T1\".\"number\" = '74s'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 349,
    "difficulty": "moderate",
    "question": "Name the card and artist with the most ruling information. Also state if the card is a promotional printing.",
    "evidence": "with the most ruling information refers to Max(count(rulings.uuid)); the card is the promotional printing refers to isPromo = 1;",
    "SQLite_query": "SELECT T1.name, T1.artist, T1.isPromo FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.isPromo = 1 GROUP BY T1.artist ORDER BY COUNT(DISTINCT T1.uuid) DESC LIMIT 1",
    "Postgres_query": "SELECT \"T1\".\"name\", \"T1\".\"artist\", \"T1\".\"isPromo\" FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"isPromo\" = 1 GROUP BY \"T1\".\"artist\" ORDER BY count(DISTINCT \"T1\".\"uuid\") DESC NULLS LAST LIMIT 1",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 350,
    "difficulty": "simple",
    "question": "State the alternative languages available for card named Annul numbered 29.",
    "evidence": "annul refers to name = 'Annul'; numbered 29 refers to number = '29';",
    "SQLite_query": "SELECT T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Annul' AND T1.number = 29",
    "Postgres_query": "SELECT \"T2\".\"language\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"name\" = 'Annul' AND \"T1\".\"number\" = 29",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 351,
    "difficulty": "simple",
    "question": "Name all the cards which have alternative language in Japanese.",
    "evidence": "Japanese' is the language;",
    "SQLite_query": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Japanese'",
    "Postgres_query": "SELECT \"T1\".\"name\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T2\".\"language\" = 'Japanese'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 352,
    "difficulty": "moderate",
    "question": "Calculate the percentage of the cards availabe in Chinese Simplified.",
    "evidence": "Chinese Simplified' is the language; percentage = Divide(Sum(id where language = 'Chinese Simplified'), Count(id)) *100",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"language\" = 'Chinese Simplified' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\"",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 353,
    "difficulty": "simple",
    "question": "List all the sets available in Italian translation. State the total number of cards per set.",
    "evidence": "Italian translation refers to language = 'Italian'; total number of card per set refers to totalSetSize;",
    "SQLite_query": "SELECT T1.name, T1.totalSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Italian'",
    "Postgres_query": "SELECT \"T1\".\"name\", \"T1\".\"totalSetSize\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T1\".\"code\" = \"T2\".\"setCode\" WHERE \"T2\".\"language\" = 'Italian'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 354,
    "difficulty": "simple",
    "question": "How many types of cards does the artist Aaron Boyd illustrated about card art?",
    "evidence": "Aaron Boyd' is artist;",
    "SQLite_query": "SELECT COUNT(type) FROM cards WHERE artist = 'Aaron Boyd'",
    "Postgres_query": "SELECT count(\"type\") FROM \"cards\" WHERE \"artist\" = 'Aaron Boyd'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 355,
    "difficulty": "simple",
    "question": "What is the keyword found on card 'Angel of Mercy'?",
    "evidence": "Angel of Mercy' is the name of card;",
    "SQLite_query": "SELECT DISTINCT keywords FROM cards WHERE name = 'Angel of Mercy'",
    "Postgres_query": "SELECT DISTINCT \"keywords\" FROM \"cards\" WHERE \"name\" = 'Angel of Mercy'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 356,
    "difficulty": "simple",
    "question": "How many cards have infinite power?",
    "evidence": "infinite power refers to power = '*';",
    "SQLite_query": "SELECT COUNT(*) FROM cards WHERE power = '*'",
    "Postgres_query": "SELECT COUNT(*) FROM \"cards\" WHERE \"power\" = '*'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 357,
    "difficulty": "simple",
    "question": "What type of promotion is of card 'Duress'?",
    "evidence": "card Duress refers to name = 'Duress'; type of promotion refers to promoTypes;",
    "SQLite_query": "SELECT promoTypes FROM cards WHERE name = 'Duress' AND promoTypes IS NOT NULL",
    "Postgres_query": "SELECT \"promoTypes\" FROM \"cards\" WHERE \"name\" = 'Duress' AND \"promoTypes\" IS NOT NULL",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 358,
    "difficulty": "simple",
    "question": "What is the border color of card \"Ancestor's Chosen\"?",
    "evidence": "Ancestor's Chosen' is the name of card;",
    "SQLite_query": "SELECT DISTINCT borderColor FROM cards WHERE name = 'Ancestor''s Chosen'",
    "Postgres_query": "SELECT DISTINCT \"borderColor\" FROM \"cards\" WHERE \"name\" = 'Ancestor''s Chosen'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 359,
    "difficulty": "simple",
    "question": "What is the type of the card \"Ancestor's Chosen\" as originally printed?",
    "evidence": "Ancestor's Chosen' is the name of card; type of the card as originally printed refers to originaltype;",
    "SQLite_query": "SELECT originalType FROM cards WHERE name = 'Ancestor''s Chosen' AND originalType IS NOT NULL",
    "Postgres_query": "SELECT \"originalType\" FROM \"cards\" WHERE \"name\" = 'Ancestor''s Chosen' AND \"originalType\" IS NOT NULL",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 360,
    "difficulty": "moderate",
    "question": "cards are not directly linked to language but through table 'set'. you need to add set in covered table & rephrase your question\nWhat are the languages available for the set that card 'Angel of Mercy' is in?",
    "evidence": "Angel of Mercy' is the name of card;",
    "SQLite_query": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM cards WHERE name = 'Angel of Mercy' )",
    "Postgres_query": "SELECT \"language\" FROM \"set_translations\" WHERE \"id\" IN ( SELECT \"id\" FROM \"cards\" WHERE \"name\" = 'Angel of Mercy' )",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 361,
    "difficulty": "simple",
    "question": "How many cards of legalities whose status is restricted have text boxes?",
    "evidence": "restricted refers to status = 'Restricted'; have text boxes refers to is Textless = 0;",
    "SQLite_query": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isTextless = 0",
    "Postgres_query": "SELECT COUNT(DISTINCT \"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T2\".\"status\" = 'Restricted' AND \"T1\".\"isTextless\" = 0",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 362,
    "difficulty": "simple",
    "question": "What is the description about the ruling of card \"Condemn\"?",
    "evidence": "Ancestor's Chosen' is the name of card; description about the ruling refers to text;",
    "SQLite_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Condemn'",
    "Postgres_query": "SELECT \"T2\".\"text\" FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"name\" = 'Condemn'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 363,
    "difficulty": "simple",
    "question": "How many cards of legalities whose status is restricted are found in a starter deck?",
    "evidence": "restricted refers to status = 'Restricted'; found in the starter deck refers to isStarter = 1;",
    "SQLite_query": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Restricted' AND T1.isStarter = 1",
    "Postgres_query": "SELECT COUNT(DISTINCT \"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T2\".\"status\" = 'Restricted' AND \"T1\".\"isStarter\" = 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 364,
    "difficulty": "simple",
    "question": "What is the status of card \"Cloudchaser Eagle\"?",
    "evidence": "Cloudchaser Eagle is the name of card;",
    "SQLite_query": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Cloudchaser Eagle'",
    "Postgres_query": "SELECT DISTINCT \"T2\".\"status\" FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"name\" = 'Cloudchaser Eagle'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 365,
    "difficulty": "simple",
    "question": "What is the type of card \"Benalish Knight\"?",
    "evidence": "Benalish Knight' is the name of card;",
    "SQLite_query": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
    "Postgres_query": "SELECT DISTINCT \"T1\".\"type\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"name\" = 'Benalish Knight'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 366,
    "difficulty": "simple",
    "question": "What is the rule of playing card \"Benalish Knight\"?",
    "evidence": "Benalish Knight' is the name of card; rule of playing card refers to format;",
    "SQLite_query": "SELECT T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Benalish Knight'",
    "Postgres_query": "SELECT \"T2\".\"format\" FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"name\" = 'Benalish Knight'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 367,
    "difficulty": "simple",
    "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
    "evidence": "Phyrexian' is the language; name of artists refers to artist;",
    "SQLite_query": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
    "Postgres_query": "SELECT \"T1\".\"artist\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T2\".\"language\" = 'Phyrexian'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 368,
    "difficulty": "simple",
    "question": "What is the percentage of borderless cards?",
    "evidence": "borderless card refers to borderColor = 'borderless'; percentage = Divide(Count (id) where borderColor = 'borderless', Count(id)) *100",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN borderColor = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"borderColor\" = 'borderless' THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(\"id\") FROM \"cards\"",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 369,
    "difficulty": "simple",
    "question": "How many cards that illusrtated in German have been reprinted?",
    "evidence": "German' is the language; reprinted refers to isReprint = 1;",
    "SQLite_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.isReprint = 1",
    "Postgres_query": "SELECT COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T2\".\"language\" = 'German' AND \"T1\".\"isReprint\" = 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 370,
    "difficulty": "simple",
    "question": "How many borderless cards are illustrated in Russian?",
    "evidence": "borderless card refers to borderColor = 'borderless'; 'Russian' is the language;",
    "SQLite_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.borderColor = 'borderless' AND T2.language = 'Russian'",
    "Postgres_query": "SELECT COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"borderColor\" = 'borderless' AND \"T2\".\"language\" = 'Russian'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 371,
    "difficulty": "challenging",
    "question": "What is the percentage of cards whose language is French among the Story Spotlight cards?",
    "evidence": "Story Spotlight card refers to isStorySpotlight = 1; French is the language; Percentage = Divide(Count(id) where language = 'French' and isStorySpotlight = 1, Count(id) where isStorySpotlight = 1)*100",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.isStorySpotlight = 1",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"language\" = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"isStorySpotlight\" = 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 372,
    "difficulty": "simple",
    "question": "How many cards are there with toughness of 99?",
    "evidence": "",
    "SQLite_query": "SELECT COUNT(id) FROM cards WHERE toughness = 99",
    "Postgres_query": "SELECT COUNT(\"id\") FROM \"cards\" WHERE \"toughness\" = 99",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 373,
    "difficulty": "simple",
    "question": "Name the cards that were illustrated by Aaron Boyd.",
    "evidence": "Aaron Boyd' is artist;",
    "SQLite_query": "SELECT DISTINCT name FROM cards WHERE artist = 'Aaron Boyd'",
    "Postgres_query": "SELECT DISTINCT \"name\" FROM \"cards\" WHERE \"artist\" = 'Aaron Boyd'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 374,
    "difficulty": "simple",
    "question": "How many black border cards are only available on mtgo?",
    "evidence": "black border card refers to borderColor = black; available on mtgo refers to availability = mtgo;\n\nadd quotes for string = 'black' and = 'mtgo'",
    "SQLite_query": "SELECT COUNT(id) FROM cards WHERE availability = 'mtgo' AND borderColor = 'black'",
    "Postgres_query": "SELECT count(\"id\") FROM \"cards\" WHERE \"availability\" = 'mtgo' AND \"borderColor\" = 'black'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 375,
    "difficulty": "simple",
    "question": "List down all the card IDs with converted mana cost of 0.",
    "evidence": "converted mana cost of 0 refers to covertedManaCost = 0;",
    "SQLite_query": "SELECT id FROM cards WHERE convertedManaCost = 0",
    "Postgres_query": "SELECT \"id\" FROM \"cards\" WHERE \"convertedManaCost\" = 0",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 376,
    "difficulty": "simple",
    "question": "What are the card layout of cards with keyword of flying?",
    "evidence": "",
    "SQLite_query": "SELECT layout FROM cards WHERE keywords = 'Flying'",
    "Postgres_query": "SELECT \"layout\" FROM \"cards\" WHERE \"keywords\" = 'Flying'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 377,
    "difficulty": "simple",
    "question": "How many cards with original type of \"Summon - Angel\" have subtype other than \"Angel\"?",
    "evidence": "subtype other than Angel refers to subtypes is not 'Angel';",
    "SQLite_query": "SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel'",
    "Postgres_query": "SELECT COUNT(\"id\") FROM \"cards\" WHERE \"originalType\" = 'Summon - Angel' AND \"subtypes\" <> 'Angel'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 378,
    "difficulty": "simple",
    "question": "What are the foiled cards that are incredibly powerful when paired with non foiled cards? List the IDs.",
    "evidence": "Incredibly powerful refers to both cardKingdomFoilId and cardKingdomId IS NOT Null;",
    "SQLite_query": "SELECT id FROM cards WHERE cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
    "Postgres_query": "SELECT \"id\" FROM \"cards\" WHERE \"cardKingdomId\" IS NOT NULL AND \"cardKingdomFoilId\" IS NOT NULL",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 379,
    "difficulty": "simple",
    "question": "What are the cards belong to duel deck a? List the ID.",
    "evidence": "duel deck a refers to duelDeck = a;",
    "SQLite_query": "SELECT id FROM cards WHERE duelDeck = 'a'",
    "Postgres_query": "SELECT \"id\" FROM \"cards\" WHERE \"duelDeck\" = 'a'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 380,
    "difficulty": "simple",
    "question": "List the edhrecRank for cards with frame version 2015.",
    "evidence": "",
    "SQLite_query": "SELECT edhrecRank FROM cards WHERE frameVersion = 2015",
    "Postgres_query": "SELECT \"edhrecRank\" FROM \"cards\" WHERE \"frameVersion\" = 2015",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 381,
    "difficulty": "simple",
    "question": "List down the name of artists for cards in Chinese Simplified.",
    "evidence": "Chinese Simplified' is the language;",
    "SQLite_query": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Chinese Simplified'",
    "Postgres_query": "SELECT \"T1\".\"artist\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T2\".\"language\" = 'Chinese Simplified'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 382,
    "difficulty": "simple",
    "question": "What are the cards that only available in paper and Japanese language?",
    "evidence": "available in paper refers to availability = 'paper'; 'Japanese is the language;",
    "SQLite_query": "SELECT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.availability = 'paper' AND T2.language = 'Japanese'",
    "Postgres_query": "SELECT \"T1\".\"name\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"availability\" = 'paper' AND \"T2\".\"language\" = 'Japanese'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 383,
    "difficulty": "simple",
    "question": "How many of the banned cards are white border?",
    "evidence": "banned card refers to status = 'Banned'; white border refers to borderColor = 'white';",
    "SQLite_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Banned' AND T1.borderColor = 'white'",
    "Postgres_query": "SELECT COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T2\".\"status\" = 'Banned' AND \"T1\".\"borderColor\" = 'white'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 384,
    "difficulty": "simple",
    "question": "List down the uuid for legacy cards and the foreign language of these cards.",
    "evidence": "legacy card refers to format = 'legacy'; foreign language refers to language in foreign_data",
    "SQLite_query": "SELECT T1.uuid, T3.language FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN foreign_data AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'legacy'",
    "Postgres_query": "SELECT \"T1\".\"uuid\", \"T3\".\"language\" FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" INNER JOIN \"foreign_data\" AS \"T3\" ON \"T1\".\"uuid\" = \"T3\".\"uuid\" WHERE \"T2\".\"format\" = 'legacy'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 385,
    "difficulty": "simple",
    "question": "Write down the ruling of Beacon of Immortality.",
    "evidence": "Beacon of Immortality' is the name of card;",
    "SQLite_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.name = 'Beacon of Immortality'",
    "Postgres_query": "SELECT \"T2\".\"text\" FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"name\" = 'Beacon of Immortality'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 386,
    "difficulty": "simple",
    "question": "How many cards are having future frame version and what are the legality status of these cards?",
    "evidence": "future frame version refers to frameVersion = 'future'; legility status refers to status = 'legal';",
    "SQLite_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.frameVersion = 'future'",
    "Postgres_query": "SELECT COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"frameVersion\" = 'future'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 387,
    "difficulty": "simple",
    "question": "What are the cards for set OGW? State the colour for these cards.",
    "evidence": "set OGW refers to setCode = 'OGW';",
    "SQLite_query": "SELECT id, colors FROM cards WHERE id IN ( SELECT id FROM set_translations WHERE setCode = 'OGW' )",
    "Postgres_query": "SELECT \"id\", \"colors\" FROM \"cards\" WHERE \"id\" IN ( SELECT \"id\" FROM \"set_translations\" WHERE \"setCode\" = 'OGW' )",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 388,
    "difficulty": "simple",
    "question": "What are the cards in set 10E with converted mana of 5 have translation and what are the languages?",
    "evidence": "set 10E refers to setCode = '10E'; converted mana of 5 refers to convertedManaCost = 5;",
    "SQLite_query": "SELECT id, language FROM set_translations WHERE id = ( SELECT id FROM cards WHERE convertedManaCost = 5 ) AND setCode = '10E'",
    "Postgres_query": "SELECT \"id\", \"language\" FROM \"set_translations\" WHERE \"id\" = ( SELECT \"id\" FROM \"cards\" WHERE \"convertedManaCost\" = 5 ) AND \"setCode\" = '10E'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 389,
    "difficulty": "simple",
    "question": "List down the name of cards with original types of Creature - Elf and the date of rulings for these cards.",
    "evidence": "Creature - Elf is the originalType;",
    "SQLite_query": "SELECT T1.id, T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Creature - Elf'",
    "Postgres_query": "SELECT \"T1\".\"id\", \"T2\".\"date\" FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"originalType\" = 'Creature - Elf'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 390,
    "difficulty": "simple",
    "question": "What are the colors of cards from ID 1-20? What are the format of these cards?",
    "evidence": "ID 1-20 refers to id BETWEEN 1 and 20;",
    "SQLite_query": "SELECT T1.colors, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.id BETWEEN 1 AND 20",
    "Postgres_query": "SELECT \"T1\".\"colors\", \"T2\".\"format\" FROM cards AS \"T1\" INNER JOIN legalities AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"id\" BETWEEN 1 AND 20",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 391,
    "difficulty": "moderate",
    "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
    "evidence": "Artifact card refers to originalType = 'Artifact'; black color refers to colors = 'B'; foreign language refers to language in foreign_data",
    "SQLite_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.originalType = 'Artifact' AND T1.colors = 'B'",
    "Postgres_query": "SELECT DISTINCT \"T1\".\"name\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"originalType\" = 'Artifact' AND \"T1\".\"colors\" = 'B'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 392,
    "difficulty": "simple",
    "question": "Pick 3 cards with rarity of uncommon, list down name these cards according to ascending order of it's ruling date.",
    "evidence": "uncommon refers to rarity = 'uncommon';",
    "SQLite_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'uncommon' ORDER BY T2.date ASC LIMIT 3",
    "Postgres_query": "SELECT DISTINCT \"T1\".\"name\" FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"rarity\" = 'uncommon' ORDER BY \"T2\".\"date\" ASC NULLS LAST LIMIT 3",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 393,
    "difficulty": "simple",
    "question": "On how many cards designed by John Avon is its foil non-powerful?",
    "evidence": "John Avon refer to artist; foil poweful foils refers to cardKingdomId and cardKingdomFoildId is NOT NULL \n",
    "SQLite_query": "SELECT COUNT(id) FROM cards WHERE (cardKingdomId IS NULL OR cardKingdomFoilId IS NULL) AND artist = 'John Avon'",
    "Postgres_query": "SELECT count(\"id\") FROM \"cards\" WHERE (\"cardKingdomId\" IS NULL OR \"cardKingdomFoilId\" IS NULL) AND \"artist\" = 'John Avon'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 394,
    "difficulty": "simple",
    "question": "How many white bordered cards are powerful?",
    "evidence": "white bordered cards refer to borderColor = 'white'; powerful cards refers to cardKingdomFoilId = cardKingdomId AND cardKingdomId is not null (replace)\n\n",
    "SQLite_query": "SELECT COUNT(id) FROM cards WHERE borderColor = 'white' AND cardKingdomId IS NOT NULL AND cardKingdomFoilId IS NOT NULL",
    "Postgres_query": "SELECT count(\"id\") FROM \"cards\" WHERE \"borderColor\" = 'white' AND \"cardKingdomId\" IS NOT NULL AND \"cardKingdomFoilId\" IS NOT NULL",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 395,
    "difficulty": "simple",
    "question": "How many cards designed by UDON and available in mtgo print type has a starting maximum hand size of -1?",
    "evidence": "UDON refer to artist; availabe in mtgo refers to availability = 'mtgo'; starting maximum hand size of -1 refers to hand = -1",
    "SQLite_query": "SELECT COUNT(id) FROM cards WHERE hAND = '-1' AND artist = 'UDON' AND Availability = 'print' AND type = 'mtgo'",
    "Postgres_query": "SELECT COUNT(\"id\") FROM \"cards\" WHERE \"hAND\" = '-1' AND \"artist\" = 'UDON' AND \"Availability\" = 'print' AND \"type\" = 'mtgo'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 396,
    "difficulty": "simple",
    "question": "How many cards with a 1993 frame version and available on paper have a sensitive content warning?",
    "evidence": "sensitive content warning refer to hasContentWarning = 1; available on paper refer to availability = 'paper' 1993 refer to frameVersion",
    "SQLite_query": "SELECT COUNT(id) FROM cards WHERE frameVersion = 1993 AND availability = 'paper' AND hasContentWarning = 1",
    "Postgres_query": "SELECT count(\"id\") FROM \"cards\" WHERE \"frameVersion\" = 1993 AND \"availability\" = 'paper' AND \"hasContentWarning\" = 1",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 397,
    "difficulty": "moderate",
    "question": "What is the mana cost of cards with a normal layout, a 2003 frame version, with a black border color, and available in paper and mtgo?",
    "evidence": "available in paper refers to availability = 'paper'; available in mtgo refers to availability = 'mtgo; frameVersion = 2003;borderColor = 'black'\n",
    "SQLite_query": "SELECT manaCost FROM cards WHERE availability = 'mtgo,paper' AND borderColor = 'black' AND frameVersion = 2003 AND layout = 'normal'",
    "Postgres_query": "SELECT \"manaCost\" FROM \"cards\" WHERE \"availability\" = 'mtgo,paper' AND \"borderColor\" = 'black' AND \"frameVersion\" = 2003 AND \"layout\" = 'normal'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 398,
    "difficulty": "simple",
    "question": "How much unconverted mana do all the cards created by Rob Alexander cost in total?",
    "evidence": "unconverted mana refer to manaCost; Rob Alexander refer to artist",
    "SQLite_query": "SELECT SUM(manaCost) FROM cards WHERE artist = 'Rob Alexander'",
    "Postgres_query": "SELECT SUM(\"manaCost\") FROM \"cards\" WHERE \"artist\" = 'Rob Alexander'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 399,
    "difficulty": "simple",
    "question": "Lists all types of cards available in arena.",
    "evidence": "all types refer to subtypes and supertypes\n\navailble in arena refers to availability = 'arena'",
    "SQLite_query": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE availability = 'arena' AND subtypes IS NOT NULL AND supertypes IS NOT NULL",
    "Postgres_query": "SELECT DISTINCT \"subtypes\", \"supertypes\" FROM \"cards\" WHERE \"availability\" = 'arena' AND \"subtypes\" IS NOT NULL AND \"supertypes\" IS NOT NULL",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 400,
    "difficulty": "simple",
    "question": "Lists the set code of all cards translated into Spanish.",
    "evidence": "Spanish refer to language; set code refers to setCode",
    "SQLite_query": "SELECT setCode FROM set_translations WHERE language = 'Spanish'",
    "Postgres_query": "SELECT \"setCode\" FROM \"set_translations\" WHERE \"language\" = 'Spanish'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 401,
    "difficulty": "moderate",
    "question": "What percentage of legendary frame effect cards have a maximum starting maximun hand\nsize of +3?",
    "evidence": "maximun hand size of +3 refer to hand = +3; legendary frame effect cards refer to frameEffects = 'legendary'; percentage refer to DIVIDE(COUNT(hand = '+3'), COUNT(id)) from cards where frameEffects = 'legendary'",
    "SQLite_query": "SELECT SUM(CASE WHEN hAND = '+3' THEN 1.0 ELSE 0 END) / COUNT(id) * 100 FROM cards WHERE frameEffects = 'legendary'",
    "Postgres_query": "SELECT SUM(CASE WHEN \"hAND\" = '+3' THEN 1.0 ELSE 0 END) / count(\"id\") * 100 FROM \"cards\" WHERE \"frameEffects\" = 'legendary'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 402,
    "difficulty": "moderate",
    "question": "What is the percentage of Story Spotlight cards that also have a text box? List them by their ID.",
    "evidence": "Story Spotlight cards that do not have a text box refers to isStorylight = 1 and isTextless = 1; Percentage refer to DIVIDE(SUM(count(id) where isStorylight = 1), SUM(count(id))) * 100\n\n",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN isTextless = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM cards WHERE isStorySpotlight = 1",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"isTextless\" = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"id\") FROM \"cards\" WHERE \"isStorySpotlight\" = 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 403,
    "difficulty": "simple",
    "question": "Calculate the percentage of cards in Spanish. List them by name.",
    "evidence": "Spanish refer to language; Percentage refer to DIVIDE(SUM(ID where language = 'Spanish'), COUNT(id))*100",
    "SQLite_query": "SELECT ( SELECT CAST(SUM(CASE WHEN language = 'Spanish' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM foreign_data ), name FROM foreign_data WHERE language = 'Spanish'",
    "Postgres_query": "SELECT ( (SELECT CAST(SUM(CASE WHEN \"language\" = 'Spanish' THEN 1 ELSE 0 END) AS FLOAT) * 100 / COUNT(*) FROM \"foreign_data\") ), \"name\" FROM \"foreign_data\" WHERE \"language\" = 'Spanish'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 404,
    "difficulty": "simple",
    "question": "Indicates the name of all the languages into which the set whose number of cards is 309 is translated.",
    "evidence": "set refer to setCode; number of cards refers to baseSetSize; baseSetsize = 309\n\n",
    "SQLite_query": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.baseSetSize = 309",
    "Postgres_query": "SELECT \"T2\".\"language\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T1\".\"code\" = \"T2\".\"setCode\" WHERE \"T1\".\"baseSetSize\" = 309",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 405,
    "difficulty": "moderate",
    "question": "How many Brazilian Portuguese translated sets are inside the Commander block?",
    "evidence": "Commander block refer to block = 'Commander'; sets refer to setCode; Portuguese refer to language = 'Portuguese (Brasil)'\n\n",
    "SQLite_query": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Portuguese (Brazil)' AND T1.block = 'Commander'",
    "Postgres_query": "SELECT COUNT(\"T1\".\"id\") FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T1\".\"code\" = \"T2\".\"setCode\" WHERE \"T2\".\"language\" = 'Portuguese (Brazil)' AND \"T1\".\"block\" = 'Commander'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 406,
    "difficulty": "simple",
    "question": "Lists by ID all Creature-type cards with legal status.",
    "evidence": "legal status refer to status = 'Legal'; Goblin-type cards refer to types = 'Creature';",
    "SQLite_query": "SELECT T1.id FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid INNER JOIN legalities AS T3 ON T1.uuid = T3.uuid WHERE T3.status = 'Legal' AND T1.types = 'Creature'",
    "Postgres_query": "SELECT \"T1\".\"id\" FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" INNER JOIN \"legalities\" AS \"T3\" ON \"T1\".\"uuid\" = \"T3\".\"uuid\" WHERE \"T3\".\"status\" = 'Legal' AND \"T1\".\"types\" = 'Creature'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 407,
    "difficulty": "moderate",
    "question": "Lists all types of cards in German.",
    "evidence": "German refer to language; all types refer to the union of subtypes and supertypes where subtypes is not null AND supertypes is not null",
    "SQLite_query": "SELECT T1.subtypes, T1.supertypes FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'German' AND T1.subtypes IS NOT NULL AND T1.supertypes IS NOT NULL",
    "Postgres_query": "SELECT \"T1\".\"subtypes\", \"T1\".\"supertypes\" FROM cards AS \"T1\" INNER JOIN foreign_data AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T2\".\"language\" = 'German' AND \"T1\".\"subtypes\" IS NOT NULL AND \"T1\".\"supertypes\" IS NOT NULL",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 408,
    "difficulty": "moderate",
    "question": "How many null power cards contain info about the triggered ability",
    "evidence": "null power cards refers to power is NULL; unknown power cards refers to power is null or power = '*'",
    "SQLite_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE (T1.power IS NULL OR T1.power LIKE '%*%') AND T2.text LIKE '%triggered ability%'",
    "Postgres_query": "SELECT \"T2\".\"text\" FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE (\"T1\".\"power\" IS NULL OR \"T1\".\"power\" LIKE '%*%') AND \"T2\".\"text\" LIKE '%triggered ability%'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 409,
    "difficulty": "moderate",
    "question": "Indicates the number of cards with pre-modern format, ruling text \"This is a triggered mana ability\" that do not have multiple faces.",
    "evidence": "do not have multiple faces refers to side IS NULL",
    "SQLite_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid INNER JOIN rulings AS T3 ON T1.uuid = T3.uuid WHERE T2.format = 'premodern' AND T3.text = 'This is a triggered mana ability.' AND T1.Side IS NULL",
    "Postgres_query": "SELECT COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" INNER JOIN \"rulings\" AS \"T3\" ON \"T1\".\"uuid\" = \"T3\".\"uuid\" WHERE \"T2\".\"format\" = 'premodern' AND \"T3\".\"text\" = 'This is a triggered mana ability.' AND \"T1\".\"Side\" IS NULL",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 410,
    "difficulty": "simple",
    "question": "Is there any card from Erica Yang artist in pauper format and available in paper? If so, indicate its ID.",
    "evidence": "available in paper refers to availability = 'paper'",
    "SQLite_query": "SELECT T1.id FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Erica Yang' AND T2.format = 'pauper' AND T1.availability = 'paper'",
    "Postgres_query": "SELECT \"T1\".\"id\" FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"artist\" = 'Erica Yang' AND \"T2\".\"format\" = 'pauper' AND \"T1\".\"availability\" = 'paper'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 411,
    "difficulty": "simple",
    "question": "To which artist does the card with the text \"Das perfekte Gegenmittel zu einer dichten Formation\" belong?",
    "evidence": "",
    "SQLite_query": "SELECT DISTINCT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.flavorText LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'",
    "Postgres_query": "SELECT DISTINCT \"T1\".\"artist\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T2\".\"flavorText\" LIKE '%DAS perfekte Gegenmittel zu einer dichten Formation%'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 412,
    "difficulty": "moderate",
    "question": "What is the foreign name of the card in French of type Creature, normal layout and black border color, by artist Matthew D. Wilson?",
    "evidence": "in French refers to language = 'French'; black border color refers to borderColor = 'black'",
    "SQLite_query": "SELECT name FROM foreign_data WHERE uuid IN ( SELECT uuid FROM cards WHERE types = 'Creature' AND layout = 'normal' AND borderColor = 'black' AND artist = 'Matthew D. Wilson' ) AND language = 'French'",
    "Postgres_query": "SELECT \"name\" FROM \"foreign_data\" WHERE \"uuid\" IN ( SELECT \"uuid\" FROM \"cards\" WHERE \"types\" = 'Creature' AND \"layout\" = 'normal' AND \"borderColor\" = 'black' AND \"artist\" = 'Matthew D. Wilson' ) AND \"language\" = 'French'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 413,
    "difficulty": "simple",
    "question": "How many cards with print rarity have ruling text printed on 10/01/2009?",
    "evidence": "with print rarity refers to rarity = 'rare'; on 10/01/2009 refers to date = '2009-01-10'",
    "SQLite_query": "SELECT COUNT(DISTINCT T1.id) FROM cards AS T1 INNER JOIN rulings AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'rare' AND T2.date = '2009-01-10'",
    "Postgres_query": "SELECT COUNT(DISTINCT \"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"rarity\" = 'rare' AND \"T2\".\"date\" = '2009-01-10'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 414,
    "difficulty": "simple",
    "question": "What language is the set of 180 cards that belongs to the Ravnica block translated into?",
    "evidence": "set of 180 cards refers to baseSetSize = 180",
    "SQLite_query": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Ravnica' AND T1.baseSetSize = 180",
    "Postgres_query": "SELECT \"T2\".\"language\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T1\".\"code\" = \"T2\".\"setCode\" WHERE \"T1\".\"block\" = 'Ravnica' AND \"T1\".\"baseSetSize\" = 180",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 415,
    "difficulty": "challenging",
    "question": "What percentage of cards with format commander and legal status do not have a content warning?",
    "evidence": "do not have a content warning refers to hasContentWarning = 0; \npercentage refers to DIVIDE(COUNT(hasContentWarning = 0),COUNT(ID))*100 where \nformat = 'commander' AND Status = 'Legal';\n",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"hasContentWarning\" = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T2\".\"format\" = 'commander' AND \"T2\".\"status\" = 'Legal'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 416,
    "difficulty": "challenging",
    "question": "What percentage of cards without power are in French?",
    "evidence": "in French refers to language = 'French'; cards without power refers to power IS NULL OR power = '*'; \npercentage = DIVIDE(COUNT(language = 'French' and power is NULL or power = '*'), COUNT( power is NULL or power = '*'))*100\n",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN T2.language = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T1.power IS NULL OR T1.power LIKE '%*%'",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"language\" = 'French' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"power\" IS NULL OR \"T1\".\"power\" LIKE '%*%'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 417,
    "difficulty": "moderate",
    "question": "What percentage of Japanese translated sets are expansion sets?",
    "evidence": "Japanese translated refers to language = 'Japanese'; expansion sets refers to type = 'expansion'; percentage = DIVIDE(COUNT(language = 'Japanese'),COUNT(language))*100",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN T2.language = 'Japanese' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.type = 'expansion'",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"language\" = 'Japanese' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"id\") FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T1\".\"code\" = \"T2\".\"setCode\" WHERE \"T1\".\"type\" = 'expansion'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 418,
    "difficulty": "simple",
    "question": "What kind of printing is on the card that Daren Bader created?",
    "evidence": "kind of printing refers to availability; Daren Bader created refers to artist = 'Daren Bader'",
    "SQLite_query": "SELECT DISTINCT availability FROM cards WHERE artist = 'Daren Bader'",
    "Postgres_query": "SELECT DISTINCT \"availability\" FROM \"cards\" WHERE \"artist\" = 'Daren Bader'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 419,
    "difficulty": "simple",
    "question": "How many color cards with no borders have been ranked higher than 12000 on EDHRec?",
    "evidence": "color cards with no borders refers to borderColor = 'borderless'; ranked higher than 12000 on EDHRec refers to edhrecRank > 12000",
    "SQLite_query": "SELECT COUNT(id) FROM cards WHERE edhrecRank > 12000 AND borderColor = 'borderless'",
    "Postgres_query": "SELECT count(\"id\") FROM \"cards\" WHERE \"edhrecRank\" > 12000 AND \"borderColor\" = 'borderless'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 420,
    "difficulty": "simple",
    "question": "How many cards are oversized, reprinted, and printed for promotions?",
    "evidence": "are oversized refers to isOversized = 1; reprinted refers to isReprint = 1; printed for promotions refers to isPromo = 1",
    "SQLite_query": "SELECT COUNT(id) FROM cards WHERE isOversized = 1 AND isReprint = 1 AND isPromo = 1",
    "Postgres_query": "SELECT count(\"id\") FROM \"cards\" WHERE \"isOversized\" = 1 AND \"isReprint\" = 1 AND \"isPromo\" = 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 421,
    "difficulty": "simple",
    "question": "Please list top three unknown power cards that have promotional types for arena league in alphabetical order.",
    "evidence": "unknown power cards refers to power is null or power = '*'; promotional types for arena league refers to promoTypes = 'arenaleague'",
    "SQLite_query": "SELECT name FROM cards WHERE (power IS NULL OR power LIKE '%*%') AND promoTypes = 'arenaleague' ORDER BY name LIMIT 3",
    "Postgres_query": "SELECT \"name\" FROM \"cards\" WHERE (\"power\" IS NULL OR \"power\" LIKE '%*%') AND \"promoTypes\" = 'arenaleague' ORDER BY \"name\" NULLS LAST LIMIT 3",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 422,
    "difficulty": "simple",
    "question": "What is the language of the card with the multiverse number 149934?",
    "evidence": "multiverse number 149934 refers to multiverseid = 149934;",
    "SQLite_query": "SELECT language FROM foreign_data WHERE multiverseid = 149934",
    "Postgres_query": "SELECT \"language\" FROM \"foreign_data\" WHERE \"multiverseid\" = 149934",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 423,
    "difficulty": "simple",
    "question": "Please provide the ids of top three powerful pairs of Kingdom Foil and Kingdom Cards sorted by Kingdom Foil id in alphabetical order.",
    "evidence": "poweful refers to cardKingdomFoilId is not null AND cardKingdomId is not null",
    "SQLite_query": "SELECT cardKingdomFoilId, cardKingdomId FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL ORDER BY cardKingdomFoilId LIMIT 3",
    "Postgres_query": "SELECT \"cardKingdomFoilId\", \"cardKingdomId\" FROM \"cards\" WHERE \"cardKingdomFoilId\" IS NOT NULL AND \"cardKingdomId\" IS NOT NULL ORDER BY \"cardKingdomFoilId\" NULLS LAST LIMIT 3",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 424,
    "difficulty": "simple",
    "question": "What proportion of cards do not have a text box with a normal layout?",
    "evidence": "do not have a text box refers to isTextless = 1; proportion refers to DIVIDE(COUNT(Textless = 1 and layout = 'normal'),COUNT(Textless))*100",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN isTextless = 1 AND layout = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM cards",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"isTextless\" = 1 AND \"layout\" = 'normal' THEN 1 ELSE 0 END) AS REAL) * 100 / count(*) FROM \"cards\"",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 425,
    "difficulty": "simple",
    "question": "What are the card numbers that don't have multiple faces on a single card and have the subtypes Angel and Wizard?",
    "evidence": "don't have multiple faces on a single card side is null",
    "SQLite_query": "SELECT id FROM cards WHERE subtypes = 'Angel,Wizard' AND side IS NULL",
    "Postgres_query": "SELECT \"id\" FROM \"cards\" WHERE \"subtypes\" = 'Angel,Wizard' AND \"side\" IS NULL",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 426,
    "difficulty": "simple",
    "question": "Please provide top three sets that don't appear in Magic: The Gathering Online, along with their names in in alphabetical order.",
    "evidence": "don't appear in Magic: The Gathering Online refers to mtgoCode is NULL or mtgoCode = ''",
    "SQLite_query": "SELECT name FROM sets WHERE mtgoCode IS NULL ORDER BY name LIMIT 3",
    "Postgres_query": "SELECT \"name\" FROM \"sets\" WHERE \"mtgoCode\" IS NULL ORDER BY \"name\" NULLS LAST LIMIT 3",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 427,
    "difficulty": "moderate",
    "question": "What languages are available in the set known as Archenemy on the magic card market and having the code ARC?",
    "evidence": "known as Archenemy refers to mcmName = 'Archenemy'; having the code ARC refers to setCode = 'ARC'",
    "SQLite_query": "SELECT T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.mcmName = 'Archenemy' AND T2.setCode = 'ARC'",
    "Postgres_query": "SELECT \"T2\".\"language\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T1\".\"code\" = \"T2\".\"setCode\" WHERE \"T1\".\"mcmName\" = 'Archenemy' AND \"T2\".\"setCode\" = 'ARC'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 428,
    "difficulty": "simple",
    "question": "What is the name of set number 5 and its translation?",
    "evidence": "set number 5 refers to id = 5",
    "SQLite_query": "SELECT T1.name, T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 5 GROUP BY T1.name, T2.translation",
    "Postgres_query": "SELECT \"T1\".\"name\", \"T2\".\"translation\" FROM sets AS \"T1\" INNER JOIN set_translations AS \"T2\" ON \"T1\".\"code\" = \"T2\".\"setCode\" WHERE \"T2\".\"id\" = 5 GROUP BY \"T1\".\"name\", \"T2\".\"translation\"",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 429,
    "difficulty": "simple",
    "question": "What is the language and expansion type of set number 206?",
    "evidence": "set number 206 refers to id = 206",
    "SQLite_query": "SELECT T2.language, T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.id = 206",
    "Postgres_query": "SELECT \"T2\".\"language\", \"T1\".\"type\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T1\".\"code\" = \"T2\".\"setCode\" WHERE \"T2\".\"id\" = 206",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 430,
    "difficulty": "simple",
    "question": "Please list top two sets of cards with their IDs that have Italian-language cards and are located in the Shadowmoor block in alphabetical order.",
    "evidence": "",
    "SQLite_query": "SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T1.block = 'Shadowmoor' AND T2.language = 'Italian' ORDER BY T1.id LIMIT 2",
    "Postgres_query": "SELECT \"T1\".\"name\", \"T1\".\"id\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T1\".\"code\" = \"T2\".\"setCode\" WHERE \"T1\".\"block\" = 'Shadowmoor' AND \"T2\".\"language\" = 'Italian' ORDER BY \"T1\".\"id\" NULLS LAST LIMIT 2",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 431,
    "difficulty": "challenging",
    "question": "Which set is not available outside of the United States and has foil cards with Japanese writing on them? Please include the set ID in your response.",
    "evidence": "available outside of the United States refers to isForeignOnly = 1; has foil cards refers to isFoilOnly = 1; with Japanese writing on them refers to language = 'Japanese'",
    "SQLite_query": "SELECT T1.name, T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Japanese' AND T1.isFoilOnly = 1 AND T1.isForeignOnly = 0",
    "Postgres_query": "SELECT \"T1\".\"name\", \"T1\".\"id\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T1\".\"code\" = \"T2\".\"setCode\" WHERE \"T2\".\"language\" = 'Japanese' AND \"T1\".\"isFoilOnly\" = 1 AND \"T1\".\"isForeignOnly\" = 0",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 432,
    "difficulty": "moderate",
    "question": "Which Russian set of cards contains the most cards overall?",
    "evidence": "Russian refers to language = 'Russian'; contains the most cards overall refers to MAX(baseSetSize)",
    "SQLite_query": "SELECT T1.id FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode WHERE T2.language = 'Russian' GROUP BY T1.baseSetSize ORDER BY COUNT(T1.id) DESC LIMIT 1",
    "Postgres_query": "SELECT \"T1\".\"id\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T1\".\"code\" = \"T2\".\"setCode\" WHERE \"T2\".\"language\" = 'Russian' GROUP BY \"T1\".\"baseSetSize\" ORDER BY count(\"T1\".\"id\") DESC NULLS LAST LIMIT 1",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 433,
    "difficulty": "moderate",
    "question": "What is the percentage of the set of cards that have Chinese Simplified as the language and are only available for online games?",
    "evidence": "are only available for online games refers to isOnlineOnly = 1; percentage = DIVIDE(COUNT(isOnlineOnly = 1),COUNT(isOnlineOnly))*100",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN T2.language = 'Chinese Simplified' AND T1.isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.code = T2.setCode",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"T2\".\"language\" = 'Chinese Simplified' AND \"T1\".\"isOnlineOnly\" = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T1\".\"code\" = \"T2\".\"setCode\"",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 434,
    "difficulty": "moderate",
    "question": "How many sets are available just in Japanese and not in Magic: The Gathering Online?",
    "evidence": "Japanese refers to language = 'Japanese'; not in Magic: The Gathering Online refers to mtgoCode is null or mtgoCode = ''",
    "SQLite_query": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.language = 'Japanese'  AND (T1.mtgoCode IS NULL OR T1.mtgoCode = '')",
    "Postgres_query": "SELECT COUNT(\"T1\".\"id\") FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T2\".\"language\" = 'Japanese' AND (\"T1\".\"mtgoCode\" IS NULL OR \"T1\".\"mtgoCode\" = '')",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 435,
    "difficulty": "simple",
    "question": "How many card border with black color ? List out the card id.",
    "evidence": "border with black color refers to borderColor = 'black'",
    "SQLite_query": "SELECT id FROM cards WHERE borderColor = 'black' GROUP BY id",
    "Postgres_query": "SELECT \"id\" FROM \"cards\" WHERE \"borderColor\" = 'black' GROUP BY \"id\"",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 436,
    "difficulty": "simple",
    "question": "How many cards have frame effect as extendedart? List out the id of those cards.",
    "evidence": "\nframe effect as extendedart refers to frameEffects = 'extendedart'\n",
    "SQLite_query": "SELECT id FROM cards WHERE frameEffects = 'extendedart' GROUP BY id",
    "Postgres_query": "SELECT \"id\" FROM \"cards\" WHERE \"frameEffects\" = 'extendedart' GROUP BY \"id\"",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 437,
    "difficulty": "simple",
    "question": "Among black card borders, which card has full artwork?",
    "evidence": "white card borders refers to borderColor = 'white'; has full artwork refers to isFullArt = 1",
    "SQLite_query": "SELECT id FROM cards WHERE borderColor = 'black' AND isFullArt = 1",
    "Postgres_query": "SELECT \"id\" FROM \"cards\" WHERE \"borderColor\" = 'black' AND \"isFullArt\" = 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 438,
    "difficulty": "simple",
    "question": "Point out the language of set id \"174\"?",
    "evidence": "",
    "SQLite_query": "SELECT language FROM set_translations WHERE id = 174",
    "Postgres_query": "SELECT \"language\" FROM \"set_translations\" WHERE \"id\" = 174",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 439,
    "difficulty": "simple",
    "question": "List out the set name of the set code \"ALL\".",
    "evidence": "",
    "SQLite_query": "SELECT name FROM sets WHERE code = 'ALL'",
    "Postgres_query": "SELECT \"name\" FROM \"sets\" WHERE \"code\" = 'ALL'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 440,
    "difficulty": "simple",
    "question": "Which foreign language used by \"A Pedra Fellwar\"?",
    "evidence": "\"A Pedra Fellwar\" refers to name = 'A Pedra Fellwar'",
    "SQLite_query": "SELECT DISTINCT language FROM foreign_data WHERE name = 'A Pedra Fellwar'",
    "Postgres_query": "SELECT DISTINCT \"language\" FROM \"foreign_data\" WHERE \"name\" = 'A Pedra Fellwar'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 441,
    "difficulty": "simple",
    "question": "State the set code of the set with release date of 07/13/2007?",
    "evidence": "",
    "SQLite_query": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.releaseDate = '2007-07-13'",
    "Postgres_query": "SELECT \"T2\".\"setCode\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T1\".\"releaseDate\" = '2007-07-13'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 442,
    "difficulty": "simple",
    "question": "Mention the base set size and set code of the set that was in block named \"Masques\" and \"Mirage\".",
    "evidence": "",
    "SQLite_query": "SELECT DISTINCT T1.baseSetSize, T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block IN ('Masques', 'Mirage')",
    "Postgres_query": "SELECT DISTINCT \"T1\".\"baseSetSize\", \"T2\".\"setCode\" FROM sets AS \"T1\" INNER JOIN set_translations AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T1\".\"block\" IN ('Masques', 'Mirage')",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 443,
    "difficulty": "simple",
    "question": "Give the code of sets have expansion type of 'expansion'?",
    "evidence": "code of sets refers to setCode",
    "SQLite_query": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'expansion' GROUP BY T2.setCode",
    "Postgres_query": "SELECT \"T2\".\"setCode\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T1\".\"type\" = 'expansion' GROUP BY \"T2\".\"setCode\"",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 444,
    "difficulty": "simple",
    "question": "Name the foreign name of the card that has boros watermark? List out the type of this card.",
    "evidence": "",
    "SQLite_query": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'boros'",
    "Postgres_query": "SELECT DISTINCT \"T1\".\"name\", \"T1\".\"type\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"watermark\" = 'boros'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 445,
    "difficulty": "simple",
    "question": "What is the language and flavor text of the card that has colorpie watermark? List out the type of this card.",
    "evidence": "",
    "SQLite_query": "SELECT DISTINCT T2.language, T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'colorpie'",
    "Postgres_query": "SELECT DISTINCT \"T2\".\"language\", \"T2\".\"flavorText\" FROM cards AS \"T1\" INNER JOIN foreign_data AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"watermark\" = 'colorpie'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 446,
    "difficulty": "moderate",
    "question": "What is percentage of the cards with a converted Mana Cost of 10 in set of Abyssal Horror?",
    "evidence": "set of Abyssal Horror refers to name = 'Abyssal Horror'; percentage refers to DIVIDE(COUNT(convertedManaCost = 16),COUNT(convertedManaCost))*100",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 10 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id), T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Abyssal Horror'",
    "Postgres_query": "SELECT (CAST(SUM(CASE WHEN \"T1\".\"convertedManaCost\" = 10 THEN 1 ELSE 0 END) AS FLOAT) * 100) / COUNT(\"T1\".\"id\"), \"T1\".\"name\" FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE \"T1\".\"name\" = 'Abyssal Horror'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 447,
    "difficulty": "simple",
    "question": "Give the code of sets have expansion commander type?",
    "evidence": "code of sets refers to setCode",
    "SQLite_query": "SELECT T2.setCode FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.type = 'commander'",
    "Postgres_query": "SELECT \"T2\".\"setCode\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T1\".\"type\" = 'commander'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 448,
    "difficulty": "simple",
    "question": "Name the foreign name of the card that has abzan watermark? List out the type of this card.",
    "evidence": "",
    "SQLite_query": "SELECT DISTINCT T1.name, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'abzan'",
    "Postgres_query": "SELECT DISTINCT \"T1\".\"name\", \"T1\".\"type\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"watermark\" = 'abzan'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 449,
    "difficulty": "simple",
    "question": "What is the language of the card that has azorius watermark? List out the type of this card.",
    "evidence": "",
    "SQLite_query": "SELECT DISTINCT T2.language, T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.watermark = 'azorius'",
    "Postgres_query": "SELECT DISTINCT \"T2\".\"language\", \"T1\".\"type\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"watermark\" = 'azorius'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 450,
    "difficulty": "moderate",
    "question": "Of all the cards that are designed by Aaron Miller, how many of them are incredibly powerful?",
    "evidence": "designed by Aaron Miller refers to artist = 'Aaron Miller'; are icredibily powerful refers to cardKingdomFoilId = cardKingdomId AND cardKingdomId is not null",
    "SQLite_query": "SELECT SUM(CASE WHEN artist = 'Aaron Miller' AND cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) FROM cards",
    "Postgres_query": "SELECT SUM(CASE WHEN \"artist\" = 'Aaron Miller' AND \"cardKingdomFoilId\" IS NOT NULL AND \"cardKingdomId\" IS NOT NULL THEN 1 ELSE 0 END) FROM \"cards\"",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 451,
    "difficulty": "simple",
    "question": "How many cards available in paper have a positive starting maximum hand size?",
    "evidence": "available in paper refers to availability like '%paper%'; have a positive starting maximum hand size refers to hand = '+%'",
    "SQLite_query": "SELECT SUM(CASE WHEN availability = 'paper' AND hAND LIKE '+%' AND hAND != '+0' THEN 1 ELSE 0 END) FROM cards",
    "Postgres_query": "SELECT SUM(CASE WHEN \"availability\" = 'paper' AND \"hAND\" LIKE '+%' AND \"hAND\" != '+0' THEN 1 ELSE 0 END) FROM \"cards\"",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 452,
    "difficulty": "simple",
    "question": "Please list the names of the cards that have a text box.",
    "evidence": "have a text box refers to isTextless = 0",
    "SQLite_query": "SELECT DISTINCT name FROM cards WHERE isTextless = 0",
    "Postgres_query": "SELECT DISTINCT \"name\" FROM \"cards\" WHERE \"isTextless\" = 0",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 453,
    "difficulty": "simple",
    "question": "What's the unconverted mana cost of the card \"Ancestor's Chosen\"?",
    "evidence": "card \"Ancestor's Chosen\" refers to name = 'Ancestor`s Chosen'",
    "SQLite_query": "SELECT DISTINCT manaCost FROM cards WHERE name = 'Ancestor''s Chosen'",
    "Postgres_query": "SELECT DISTINCT \"manaCost\" FROM \"cards\" WHERE \"name\" = 'Ancestor''s Chosen'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 454,
    "difficulty": "simple",
    "question": "Among the cards with a white border color, how many of them have unknown power?",
    "evidence": "unknown power refers to power = '*' or power is null",
    "SQLite_query": "SELECT SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE borderColor = 'white'",
    "Postgres_query": "SELECT SUM(CASE WHEN \"power\" LIKE '%*%' OR \"power\" IS NULL THEN 1 ELSE 0 END) FROM \"cards\" WHERE \"borderColor\" = 'white'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 455,
    "difficulty": "simple",
    "question": "Which of the cards that are a promotional painting have multiple faces on the same card? Please list their names.",
    "evidence": "are a promotional painting refers to isPromo = 1; have multiple faces on the same card refers to side is not Null",
    "SQLite_query": "SELECT DISTINCT name FROM cards WHERE isPromo = 1 AND side IS NOT NULL",
    "Postgres_query": "SELECT DISTINCT \"name\" FROM \"cards\" WHERE \"isPromo\" = 1 AND \"side\" IS NOT NULL",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 456,
    "difficulty": "simple",
    "question": "What's the list of all types for the card \"Molimo, Maro-Sorcerer\"?",
    "evidence": "card \"Molimo, Maro-Sorcerer\" refers to name = 'Molimo, Maro-Sorcerer'; list of all types refers to subtypes,supertypes",
    "SQLite_query": "SELECT DISTINCT subtypes, supertypes FROM cards WHERE name = 'Molimo, Maro-Sorcerer'",
    "Postgres_query": "SELECT DISTINCT \"subtypes\", \"supertypes\" FROM \"cards\" WHERE \"name\" = 'Molimo, Maro-Sorcerer'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 457,
    "difficulty": "simple",
    "question": "Please list the websites where I can purchase the cards that have the promotional type of \"bundle\".",
    "evidence": "promotional type of \"bundle\" refers to promoTypes = 'bundle'; websites refers to purchaseUrls",
    "SQLite_query": "SELECT DISTINCT purchaseUrls FROM cards WHERE promoTypes = 'bundle'",
    "Postgres_query": "SELECT DISTINCT \"purchaseUrls\" FROM \"cards\" WHERE \"promoTypes\" = 'bundle'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 458,
    "difficulty": "simple",
    "question": "How many artists have designed a card with a black border color and is available in both \"arena\" and \"mtgo\" printing type?",
    "evidence": "available in both \"arena\" and \"mtgo\" refers to availability like '%arena,mtgo%'",
    "SQLite_query": "SELECT COUNT(CASE WHEN availability LIKE '%arena,mtgo%' THEN 1 ELSE NULL END) FROM cards",
    "Postgres_query": "SELECT COUNT(CASE WHEN \"availability\" ILIKE '%arena,mtgo%' THEN 1 ELSE NULL END) FROM \"cards\"",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 459,
    "difficulty": "moderate",
    "question": "Which card costs more converted mana, \"Serra Angel\" or \"Shrine Keeper\"?",
    "evidence": "\"Serra Angel\" refers to name = 'Serra Angel'; \"Shrine Keeper\" refers to name = 'Shrine Keeper'; \ncard costs more converted mana when the value of convertedManaCost is greater",
    "SQLite_query": "SELECT name FROM cards WHERE name IN ('Serra Angel', 'Shrine Keeper') ORDER BY convertedManaCost DESC LIMIT 1",
    "Postgres_query": "SELECT \"name\" FROM \"cards\" WHERE \"name\" IN ('Serra Angel', 'Shrine Keeper') ORDER BY \"convertedManaCost\" DESC NULLS LAST LIMIT 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 460,
    "difficulty": "simple",
    "question": "Which artist designed the card whose promotional name is \"Battra, Dark Destroyer\"?",
    "evidence": "promotional name is \"Battra, Dark Destroyer\" refers to flavorName = 'Battra, Dark Destroyer'",
    "SQLite_query": "SELECT artist FROM cards WHERE flavorName = 'Battra, Dark Destroyer'",
    "Postgres_query": "SELECT \"artist\" FROM \"cards\" WHERE \"flavorName\" = 'Battra, Dark Destroyer'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 461,
    "difficulty": "simple",
    "question": "Please list the names of the top 3 cards with the highest converted mana cost and have a 2003 card frame style.",
    "evidence": "name of cards refers to name; 2003 card frame style refers to frameVersion = '2003'",
    "SQLite_query": "SELECT name FROM cards WHERE frameVersion = 2003 ORDER BY convertedManaCost DESC LIMIT 3",
    "Postgres_query": "SELECT \"name\" FROM \"cards\" WHERE \"frameVersion\" = 2003 ORDER BY \"convertedManaCost\" DESC NULLS LAST LIMIT 3",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 462,
    "difficulty": "moderate",
    "question": "What's the Italian name of the set of cards with \"Ancestor's Chosen\" is in?",
    "evidence": "Italian is a language which refers to language = 'Italian'; with \"Ancestor's Chosen\" in the card set refers to name = 'Ancestor's Chosen'",
    "SQLite_query": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Ancestor''s Chosen' ) AND language = 'Italian'",
    "Postgres_query": "SELECT \"translation\" FROM \"set_translations\" WHERE \"setCode\" IN ( SELECT \"setCode\" FROM \"cards\" WHERE \"name\" = 'Ancestor''s Chosen' ) AND \"language\" = 'Italian'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 463,
    "difficulty": "simple",
    "question": "How many translations are there for the set of cards with \"Angel of Mercy\" in it?",
    "evidence": "set of cards with \"Angel of Mercy\" in it refers to name = 'Angel of Mercy'",
    "SQLite_query": "SELECT COUNT(DISTINCT translation) FROM set_translations WHERE setCode IN ( SELECT setCode FROM cards WHERE name = 'Angel of Mercy' ) AND translation IS NOT NULL",
    "Postgres_query": "SELECT COUNT(DISTINCT \"translation\") FROM \"set_translations\" WHERE \"setCode\" IN ( SELECT \"setCode\" FROM \"cards\" WHERE \"name\" = 'Angel of Mercy' ) AND \"translation\" IS NOT NULL",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 464,
    "difficulty": "simple",
    "question": "Please list the names of the cards in the set \"Hauptset Zehnte Edition\".",
    "evidence": "card set \"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'",
    "SQLite_query": "SELECT DISTINCT T1.name FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition'",
    "Postgres_query": "SELECT DISTINCT \"T1\".\"name\" FROM \"cards\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"setCode\" WHERE \"T2\".\"translation\" = 'Hauptset Zehnte Edition'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 465,
    "difficulty": "moderate",
    "question": "For the set of cards with \"Ancestor's Chosen\" in it, is there a Korean version of it?",
    "evidence": "set of cards with \"Ancestor's Chosen\" in it refers to name = 'Ancestor's Chosen'; Korean version refers to language = 'Korean'",
    "SQLite_query": "SELECT IIF(SUM(CASE WHEN T2.language = 'Korean' AND T2.translation IS NOT NULL THEN 1 ELSE 0 END) > 0, 'YES', 'NO') FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
    "Postgres_query": "SELECT CASE WHEN SUM(CASE WHEN \"T2\".\"language\" = 'Korean' AND \"T2\".\"translation\" IS NOT NULL THEN 1 ELSE 0 END) > 0 THEN 'YES' ELSE 'NO' END FROM \"cards\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"setCode\" WHERE \"T1\".\"name\" = 'Ancestor''s Chosen'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 466,
    "difficulty": "moderate",
    "question": "Among the cards in the set \"Hauptset Zehnte Edition\", how many of them are designed by Adam Rex?",
    "evidence": "card set \"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'; designed by Adam refers to artist = 'Adam Rex'",
    "SQLite_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T2.translation = 'Hauptset Zehnte Edition' AND T1.artist = 'Adam Rex'",
    "Postgres_query": "SELECT COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"setCode\" WHERE \"T2\".\"translation\" = 'Hauptset Zehnte Edition' AND \"T1\".\"artist\" = 'Adam Rex'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 467,
    "difficulty": "simple",
    "question": "How many cards are there in the base set of \"Hauptset Zehnte Edition\"?",
    "evidence": "\"Hauptset Zehnte Edition\" refers to translation = 'Hauptset Zehnte Edition'; number of cards refers to baseSetSize",
    "SQLite_query": "SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Hauptset Zehnte Edition'",
    "Postgres_query": "SELECT \"T1\".\"baseSetSize\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T2\".\"translation\" = 'Hauptset Zehnte Edition'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 468,
    "difficulty": "moderate",
    "question": "What is the Simplified Chinese translation of the name of the set \"Eighth Edition\"?",
    "evidence": "Eighth Edition is the name of card set which refers to name = 'Eighth Edition'; Simplified Chinese is the language; translation of the name refers to translation",
    "SQLite_query": "SELECT T2.translation FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Eighth Edition' AND T2.language = 'Chinese Simplified'",
    "Postgres_query": "SELECT \"T2\".\"translation\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T1\".\"name\" = 'Eighth Edition' AND \"T2\".\"language\" = 'Chinese Simplified'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 469,
    "difficulty": "moderate",
    "question": "Did the set of cards with \"Angel of Mercy\" appear on Magic: The Gathering Online?",
    "evidence": "card set \"Angel of Mercy\" refers to name = 'Angel of Mercy'; appear on Magic: The Gathering Online refers to mtgoCode is NOT NULL and vice versa",
    "SQLite_query": "SELECT IIF(T2.mtgoCode IS NOT NULL, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Angel of Mercy'",
    "Postgres_query": "SELECT CASE WHEN \"T2\".\"mtgoCode\" IS NOT NULL THEN 'YES' ELSE 'NO' END FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE \"T1\".\"name\" = 'Angel of Mercy'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 470,
    "difficulty": "simple",
    "question": "When was the set of cards with \"Ancestor's Chosen\" released?",
    "evidence": "card set \"Ancestor's Chosen\" refers to name = 'Ancestor''s Chosen'; when released refers to releaseDate",
    "SQLite_query": "SELECT DISTINCT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Ancestor''s Chosen'",
    "Postgres_query": "SELECT DISTINCT \"T2\".\"releaseDate\" FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE \"T1\".\"name\" = 'Ancestor''s Chosen'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 471,
    "difficulty": "simple",
    "question": "What is the expansion type of the set \"Hauptset Zehnte Edition\"?",
    "evidence": "card set \"Hauptset Zehnte Edition\" refers to translation = ' Hauptset Zehnte Edition'; expansion type refers to type",
    "SQLite_query": "SELECT T1.type FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Hauptset Zehnte Edition'",
    "Postgres_query": "SELECT \"T1\".\"type\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T2\".\"translation\" = 'Hauptset Zehnte Edition'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 472,
    "difficulty": "moderate",
    "question": "Among the sets in the block \"Ice Age\", how many of them have an Italian translation?",
    "evidence": "sets in the block \"Ice Age\" refers to block = 'Ice Age'; Italian translation refers to language = 'Italian'",
    "SQLite_query": "SELECT COUNT(DISTINCT T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.block = 'Ice Age' AND T2.language = 'Italian' AND T2.translation IS NOT NULL",
    "Postgres_query": "SELECT COUNT(DISTINCT \"T1\".\"id\") FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T1\".\"block\" = 'Ice Age' AND \"T2\".\"language\" = 'Italian' AND \"T2\".\"translation\" IS NOT NULL",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 473,
    "difficulty": "moderate",
    "question": "Is the set of cards with Adarkar Valkyrie only available outside the United States?",
    "evidence": "card set Adarkar Valkyrie refers to name = 'Adarkar Valkyrie'; isForeignOnly = 1 means only available outside the United States;",
    "SQLite_query": "SELECT IIF(isForeignOnly = 1, 'YES', 'NO') FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Adarkar Valkyrie'",
    "Postgres_query": "SELECT CASE WHEN \"isForeignOnly\" = 1 THEN 'YES' ELSE 'NO' END FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE \"T1\".\"name\" = 'Adarkar Valkyrie'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 474,
    "difficulty": "moderate",
    "question": "Among the sets of cards that have an Italian translation, how many of them have a base set number of under 10?",
    "evidence": "Italian translation refers to language = 'Italian'; have a translation means translation is not null; base set number of under 10 refers to baseSetSize < 10",
    "SQLite_query": "SELECT COUNT(T1.id) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation IS NOT NULL AND T1.baseSetSize < 10 AND T2.language = 'Italian'",
    "Postgres_query": "SELECT COUNT(\"T1\".\"id\") FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T2\".\"translation\" IS NOT NULL AND \"T1\".\"baseSetSize\" < 10 AND \"T2\".\"language\" = 'Italian'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 475,
    "difficulty": "simple",
    "question": "How many cards in the set Coldsnap have a black border color?",
    "evidence": "card set Coldsnap refers to name = 'Coldsnap'; black border color refers to borderColor = 'black'",
    "SQLite_query": "SELECT SUM(CASE WHEN T1.borderColor = 'black' THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
    "Postgres_query": "SELECT SUM(CASE WHEN \"T1\".\"borderColor\" = 'black' THEN 1 ELSE 0 END) FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE \"T2\".\"name\" = 'Coldsnap'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 476,
    "difficulty": "simple",
    "question": "Please list the name of the cards in the set Coldsnap with the highest converted mana cost.",
    "evidence": "card set Coldsnap refers to name = 'Coldsnap'",
    "SQLite_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' ORDER BY T1.convertedManaCost DESC LIMIT 1",
    "Postgres_query": "SELECT \"T1\".\"name\" FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE \"T2\".\"name\" = 'Coldsnap' ORDER BY \"T1\".\"convertedManaCost\" DESC NULLS LAST LIMIT 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 477,
    "difficulty": "challenging",
    "question": "Which of these artists have designed a card in the set Coldsnap, Jeremy Jarvis, Aaron Miller or Chippy?",
    "evidence": "card set Coldsnap refers to name = 'Coldsnap'; Jeremy Jarvis, Aaron Miller or Chippy are the name of artists which refers to artist IN ('Jeremy Jarvis', 'Aaron Miller','Chippy');",
    "SQLite_query": "SELECT T1.artist FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE (T2.name = 'Coldsnap' AND T1.artist = 'Chippy') OR (T2.name = 'Coldsnap' AND T1.artist = 'Aaron Miller') OR (T2.name = 'Coldsnap' AND T1.artist = 'Jeremy Jarvis') GROUP BY T1.artist",
    "Postgres_query": "SELECT \"T1\".\"artist\" FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE (\"T2\".\"name\" = 'Coldsnap' AND \"T1\".\"artist\" = 'Chippy') OR (\"T2\".\"name\" = 'Coldsnap' AND \"T1\".\"artist\" = 'Aaron Miller') OR (\"T2\".\"name\" = 'Coldsnap' AND \"T1\".\"artist\" = 'Jeremy Jarvis') GROUP BY \"T1\".\"artist\"",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 478,
    "difficulty": "simple",
    "question": "What is card number 4 in the set Coldsnap?",
    "evidence": "card set Coldsnap refers to name = 'Coldsnap'; card number 4 refers to number = 4",
    "SQLite_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.number = 4",
    "Postgres_query": "SELECT \"T1\".\"name\" FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE \"T2\".\"name\" = 'Coldsnap' AND \"T1\".\"number\" = 4",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 479,
    "difficulty": "moderate",
    "question": "Among the cards with converted mana cost higher than 5 in the set Coldsnap, how many of them have unknown power?",
    "evidence": "card set Coldsnap refers to name = 'Coldsnap'; converted mana cost higher than 5 refers to convertedManaCost > 5; unknown power refers to power = '*' or T1.power is null",
    "SQLite_query": "SELECT SUM(CASE WHEN T1.power LIKE '%*%' OR T1.power IS NULL THEN 1 ELSE 0 END) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap' AND T1.convertedManaCost > 5",
    "Postgres_query": "SELECT SUM(CASE WHEN \"T1\".\"power\" ILIKE '%*%' OR \"T1\".\"power\" IS NULL THEN 1 ELSE 0 END) FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE \"T2\".\"name\" = 'Coldsnap' AND \"T1\".\"convertedManaCost\" > 5",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 480,
    "difficulty": "moderate",
    "question": "What is the Italian flavor text of the card \"Ancestor's Chosen\"?",
    "evidence": "Italian refers to language = 'Italian'; flavor text refers to flavorText; \"Ancestor''s Chosen\" refers to name = 'Ancestor''s Chosen'",
    "SQLite_query": "SELECT T2.flavorText FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'Italian'",
    "Postgres_query": "SELECT \"T2\".\"flavorText\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"name\" = 'Ancestor''s Chosen' AND \"T2\".\"language\" = 'Italian'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 481,
    "difficulty": "simple",
    "question": "Please list all the foreign languages in which the card \"Ancestor's Chosen\" has a flavor text.",
    "evidence": "\"Ancestor''s Chosen\" refers to name = 'Ancestor''s Chosen'; has a flavor text refers to flavorText is not null",
    "SQLite_query": "SELECT T2.language FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.flavorText IS NOT NULL",
    "Postgres_query": "SELECT \"T2\".\"language\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"name\" = 'Ancestor''s Chosen' AND \"T2\".\"flavorText\" IS NOT NULL",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 482,
    "difficulty": "simple",
    "question": "What's the German type of the card \"Ancestor's Chosen\"?",
    "evidence": "German refers to language = 'German'; \"Ancestor's Chosen\" refers to name = 'Ancestor''s Chosen'",
    "SQLite_query": "SELECT DISTINCT T1.type FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Ancestor''s Chosen' AND T2.language = 'German'",
    "Postgres_query": "SELECT DISTINCT \"T1\".\"type\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"name\" = 'Ancestor''s Chosen' AND \"T2\".\"language\" = 'German'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 483,
    "difficulty": "moderate",
    "question": "Please list the Italian text ruling of all the cards in the set Coldsnap.",
    "evidence": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'",
    "SQLite_query": "SELECT DISTINCT T1.text FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian'",
    "Postgres_query": "SELECT DISTINCT \"T1\".\"text\" FROM foreign_data AS \"T1\" INNER JOIN cards AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" INNER JOIN sets AS \"T3\" ON \"T3\".\"code\" = \"T2\".\"setCode\" WHERE \"T3\".\"name\" = 'Coldsnap' AND \"T1\".\"language\" = 'Italian'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 484,
    "difficulty": "moderate",
    "question": "Please list the Italian names of the cards in the set Coldsnap with the highest converted mana cost.",
    "evidence": "card set Coldsnap refers to name = 'Coldsnap'; Italian refers to language = 'Italian'",
    "SQLite_query": "SELECT T2.name FROM foreign_data AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid INNER JOIN sets AS T3 ON T3.code = T2.setCode WHERE T3.name = 'Coldsnap' AND T1.language = 'Italian' ORDER BY T2.convertedManaCost DESC LIMIT 1",
    "Postgres_query": "SELECT \"T2\".\"name\" FROM foreign_data AS \"T1\" INNER JOIN cards AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" INNER JOIN sets AS \"T3\" ON \"T3\".\"code\" = \"T2\".\"setCode\" WHERE \"T3\".\"name\" = 'Coldsnap' AND \"T1\".\"language\" = 'Italian' ORDER BY \"T2\".\"convertedManaCost\" DESC NULLS LAST LIMIT 1",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 485,
    "difficulty": "simple",
    "question": "When was the ruling for the card 'Reminisce' created?",
    "evidence": "Reminisce refers to name = 'Reminisce'; when created is the date",
    "SQLite_query": "SELECT T2.date FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.name = 'Reminisce'",
    "Postgres_query": "SELECT \"T2\".\"date\" FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"name\" = 'Reminisce'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 486,
    "difficulty": "moderate",
    "question": "What is the percentage of the cards with a converted mana cost of 7 in the set Coldsnap?",
    "evidence": "converted mana cost of 7 refers to convertedManaCost = 7; card set Coldsnap refers to name = 'Coldsnap'; percentage = DIVIDE(SUM(convertedManaCost = 7), SUM(convertedManaCost))*100",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN T1.convertedManaCost = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"convertedManaCost\" = 7 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE \"T2\".\"name\" = 'Coldsnap'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 487,
    "difficulty": "challenging",
    "question": "What is the percentage of incredibly powerful cards in the set Coldsnap?",
    "evidence": "card set Coldsnap refers to name = 'Coldsnap'; foil is incredibly powerful refers to cardKingdomFoilId = cardKingdomId AND cardKingdomId is not null; the percentage of incredibly powerful cards in the set refers to DIVIDE(SUM(incredibly powerful), SUM(name = 'Coldsnap'))*100\n\n",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"T1\".\"cardKingdomFoilId\" IS NOT NULL AND \"T1\".\"cardKingdomId\" IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE \"T2\".\"name\" = 'Coldsnap'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 488,
    "difficulty": "simple",
    "question": "What's the code for the set which was released on 2017/7/14?",
    "evidence": "released on 2017/7/14 refers to releaseDate = '2017-07-14'",
    "SQLite_query": "SELECT code FROM sets WHERE releaseDate = '2017-07-14' GROUP BY releaseDate, code",
    "Postgres_query": "SELECT \"code\" FROM \"sets\" WHERE \"releaseDate\" = '2017-07-14' GROUP BY \"releaseDate\", \"code\"",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 489,
    "difficulty": "simple",
    "question": "List the keyrune code for the set whose code is 'PKHC'.",
    "evidence": "keyrune code refers to keyruneCode",
    "SQLite_query": "SELECT keyruneCode FROM sets WHERE code = 'PKHC'",
    "Postgres_query": "SELECT \"keyruneCode\" FROM \"sets\" WHERE \"code\" = 'PKHC'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 490,
    "difficulty": "simple",
    "question": "For the set which had 'SS2' as the code, what is its magic card market id?",
    "evidence": "magic card market id refers to mcmId",
    "SQLite_query": "SELECT mcmId FROM sets WHERE code = 'SS2'",
    "Postgres_query": "SELECT \"mcmId\" FROM \"sets\" WHERE \"code\" = 'SS2'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 491,
    "difficulty": "simple",
    "question": "What's the magic card market name for the set which was released on 2017/6/9?",
    "evidence": "magic card market name refers to mcmName",
    "SQLite_query": "SELECT mcmName FROM sets WHERE releaseDate = '2017-06-09'",
    "Postgres_query": "SELECT \"mcmName\" FROM \"sets\" WHERE \"releaseDate\" = '2017-06-09'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 492,
    "difficulty": "simple",
    "question": "For the set \"From the Vault: Lore\", what is its expansion type?",
    "evidence": "set \"From the Vault refers to name which contains 'From the Vault: Lore'; expansion type refers to type",
    "SQLite_query": "SELECT type FROM sets WHERE name LIKE '%FROM the Vault: Lore%'",
    "Postgres_query": "SELECT \"type\" FROM \"sets\" WHERE \"name\" ILIKE '%FROM the Vault: Lore%'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 493,
    "difficulty": "simple",
    "question": "For the set \"Commander 2014 Oversized\" , give its parent code.",
    "evidence": "the set \"Commander 2014 Oversized\" refers to name = 'Commander 2014 Oversized';",
    "SQLite_query": "SELECT parentCode FROM sets WHERE name = 'Commander 2014 Oversized'",
    "Postgres_query": "SELECT \"parentCode\" FROM \"sets\" WHERE \"name\" = 'Commander 2014 Oversized'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 494,
    "difficulty": "challenging",
    "question": "For all cards illustrated by Jim Pavelec. and describe the text of the ruling of these cards. Do these cards have missing or degraded properties and values.",
    "evidence": "all cards illustrated by Jim Pavelec refers to artist = 'Jim Pavelec'; the text of the ruling refers to text; cards have missing or degraded properties and values if hasContentWarning = 1 else it doesn't have;",
    "SQLite_query": "SELECT T2.text , CASE WHEN T1.hasContentWarning = 1 THEN 'YES' ELSE 'NO' END FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Jim Pavelec'",
    "Postgres_query": "SELECT \"T2\".\"text\" , CASE WHEN \"T1\".\"hasContentWarning\" = 1 THEN 'YES' ELSE 'NO' END FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"artist\" = 'Jim Pavelec'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 495,
    "difficulty": "simple",
    "question": "What was the release date for the set which card \"Evacuation\" in it?",
    "evidence": "\"Evacuation\" refers to name = 'Evacuation'; release date refers to releaseDate",
    "SQLite_query": "SELECT T2.releaseDate FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T1.name = 'Evacuation'",
    "Postgres_query": "SELECT \"T2\".\"releaseDate\" FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE \"T1\".\"name\" = 'Evacuation'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 496,
    "difficulty": "simple",
    "question": "What is the number of cards are there in the set of \"Rinascita di Alara\"?",
    "evidence": "number of cards refers to baseSetSize; set of \"Rinascita di Alara\" refers to translation = 'Rinascita di Alara'",
    "SQLite_query": "SELECT T1.baseSetSize FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Rinascita di Alara'",
    "Postgres_query": "SELECT \"T1\".\"baseSetSize\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T2\".\"translation\" = 'Rinascita di Alara'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 497,
    "difficulty": "simple",
    "question": "List the expansion type of the set \"Huiti\u00e8me \u00e9dition\".",
    "evidence": "the set \"Huiti\u00e8me \u00e9dition\" refers to translation = 'Huiti\u00e8me \u00e9dition'; expansion type refers to type",
    "SQLite_query": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00e8me \u00e9dition' )",
    "Postgres_query": "SELECT \"type\" FROM \"sets\" WHERE \"code\" IN ( SELECT \"setCode\" FROM \"set_translations\" WHERE \"translation\" = 'Huiti\u00e8me \u00e9dition' )",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 498,
    "difficulty": "moderate",
    "question": "What's the French name of the set of cards with \"Tendo Ice Bridge\" is in?",
    "evidence": "French refers to language = 'French'; \"Tendo Ice Bridge\" is a translated name of a card; translated name refers to translation",
    "SQLite_query": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Tendo Ice Bridge' AND T2.language = 'French' AND T2.translation IS NOT NULL",
    "Postgres_query": "SELECT \"T2\".\"translation\" FROM \"cards\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"setCode\" WHERE \"T1\".\"name\" = 'Tendo Ice Bridge' AND \"T2\".\"language\" = 'French' AND \"T2\".\"translation\" IS NOT NULL",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 499,
    "difficulty": "moderate",
    "question": "How many translations of the name of the set \"Salvat 2011\"?",
    "evidence": "translations of the name refers to translation; translation is not NULL; set \"Salvat 2011\" refers to name = 'Salvat 2011'",
    "SQLite_query": "SELECT COUNT(DISTINCT T2.translation) FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T1.name = 'Salvat 2011' AND T2.translation IS NOT NULL",
    "Postgres_query": "SELECT COUNT(DISTINCT \"T2\".\"translation\") FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T1\".\"name\" = 'Salvat 2011' AND \"T2\".\"translation\" IS NOT NULL",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 500,
    "difficulty": "moderate",
    "question": "Tell the Japanese name of the set which card \"Fellwar Stone\" is in it.",
    "evidence": "Japanese name refers to language = 'Japanese'; card \"Fellwar Stone\" refers to name = 'Fellwar Stone'",
    "SQLite_query": "SELECT T2.translation FROM cards AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.setCode WHERE T1.name = 'Fellwar Stone' AND T2.language = 'Japanese' AND T2.translation IS NOT NULL",
    "Postgres_query": "SELECT \"T2\".\"translation\" FROM \"cards\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"setCode\" WHERE \"T1\".\"name\" = 'Fellwar Stone' AND \"T2\".\"language\" = 'Japanese' AND \"T2\".\"translation\" IS NOT NULL",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 501,
    "difficulty": "moderate",
    "question": "Which card name in the set 'Journey into Nyx Hero's Path' has the highest converted mana cost.",
    "evidence": "set 'Journey into Nyx Hero's Path' refers to name = 'Journey into Nyx Hero''s Path'",
    "SQLite_query": "SELECT T1.name FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Journey into Nyx Hero''s Path' ORDER BY T1.convertedManaCost DESC LIMIT 1",
    "Postgres_query": "SELECT \"T1\".\"name\" FROM \"cards\" AS \"T1\" INNER JOIN \"sets\" AS \"T2\" ON \"T2\".\"code\" = \"T1\".\"setCode\" WHERE \"T2\".\"name\" = 'Journey into Nyx Hero''s Path' ORDER BY \"T1\".\"convertedManaCost\" DESC NULLS LAST LIMIT 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 502,
    "difficulty": "simple",
    "question": "What is the release date for the set \"Ola de fr\u00edo\"?",
    "evidence": "release date is the date of card set being released; set \"Ola de fr\u00edo\" refers to translation = 'Ola de fr\u00edo'",
    "SQLite_query": "SELECT T1.releaseDate FROM sets AS T1 INNER JOIN set_translations AS T2 ON T2.setCode = T1.code WHERE T2.translation = 'Ola de fr\u00edo'",
    "Postgres_query": "SELECT \"T1\".\"releaseDate\" FROM \"sets\" AS \"T1\" INNER JOIN \"set_translations\" AS \"T2\" ON \"T2\".\"setCode\" = \"T1\".\"code\" WHERE \"T2\".\"translation\" = 'Ola de fr\u00edo'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 503,
    "difficulty": "simple",
    "question": "What was the expansion type for the set which card \"Samite Pilgrim\" in it?",
    "evidence": "expansion type refers to type; card \"Samite Pilgrim\" refers to name = 'Samite Pilgrim'",
    "SQLite_query": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM cards WHERE name = 'Samite Pilgrim' )",
    "Postgres_query": "SELECT \"type\" FROM \"sets\" WHERE \"code\" IN ( SELECT \"setCode\" FROM \"cards\" WHERE \"name\" = 'Samite Pilgrim' )",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 504,
    "difficulty": "simple",
    "question": "How many cards are there in the set 'World Championship Decks 2004' with the converted mana cost as '3'.",
    "evidence": "the set 'World Championship Decks 2004' refers to name = 'World Championship Decks 2004'",
    "SQLite_query": "SELECT COUNT(id) FROM cards WHERE setCode IN ( SELECT code FROM sets WHERE name = 'World Championship Decks 2004' ) AND convertedManaCost = 3",
    "Postgres_query": "SELECT count(\"id\") FROM \"cards\" WHERE \"setCode\" IN (SELECT \"code\" FROM \"sets\" WHERE \"name\" = 'World Championship Decks 2004') AND \"convertedManaCost\" = 3",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 505,
    "difficulty": "moderate",
    "question": "Show the Simplified Chinese translation of the name of the set \"Mirrodin\"?",
    "evidence": "Simplified Chinese translation refers to language = 'Chinese Simplified'; name of the set \"Mirrodin\" refers to name = 'Mirrodin'",
    "SQLite_query": "SELECT translation FROM set_translations WHERE setCode IN ( SELECT code FROM sets WHERE name = 'Mirrodin' ) AND language = 'Chinese Simplified'",
    "Postgres_query": "SELECT \"translation\" FROM \"set_translations\" WHERE \"setCode\" IN ( SELECT \"code\" FROM \"sets\" WHERE \"name\" = 'Mirrodin' ) AND \"language\" = 'Chinese Simplified'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 506,
    "difficulty": "challenging",
    "question": "For all the set of cards that has Japanese translation, what is the percentage of them are only available in non-foil?",
    "evidence": "Japanese translation refers to language = 'Japanese'; in non-foil refers to isNonFoilOnly = 1; percentage of Japanese non foil in Japanese cards refers to DIVIDE(SUM(isNonFoilOnly = 1), SUM(language = 'Japanese'))*100",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN isNonFoilOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Japanese' )",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"isNonFoilOnly\" = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(\"id\") FROM \"sets\" WHERE \"code\" IN ( SELECT \"setCode\" FROM \"set_translations\" WHERE \"language\" = 'Japanese' )",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 507,
    "difficulty": "challenging",
    "question": "For all the set of cards that has Brazil Portuguese translation, what is the percentage of them are only available online?",
    "evidence": "Brazil Portuguese translation refers to language = 'Portuguese (Brazil)'; only available online refers to isOnlineOnly = 1; percentage of online only Brazil Portuguese in all Brazil Portuguese cards refers to DIVIDE(SUM(isOnlineOnly = 1), SUM(language = 'Portuguese (Brazil)))*100",
    "SQLite_query": "SELECT CAST(SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)' )",
    "Postgres_query": "SELECT CAST(SUM(CASE WHEN \"isOnlineOnly\" = 1 THEN 1 ELSE 0 END) AS REAL) * 100.0 / COUNT(\"id\") FROM \"sets\" WHERE \"code\" IN ( SELECT \"setCode\" FROM \"set_translations\" WHERE \"language\" = 'Portuguese (Brazil)' )",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 508,
    "difficulty": "moderate",
    "question": "What are the available printing types of the cards that doesn't have a text box created by Aleksi Briclot?",
    "evidence": "created by Aleksi Briclot refers to artist = 'Aleksi Briclot'; doesn't have a text box refers to isTextless = 1; available printing types refers to availability",
    "SQLite_query": "SELECT DISTINCT availability FROM cards WHERE artist = 'Aleksi Briclot' AND isTextless = 1",
    "Postgres_query": "SELECT DISTINCT \"availability\" FROM \"cards\" WHERE \"artist\" = 'Aleksi Briclot' AND \"isTextless\" = 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 509,
    "difficulty": "simple",
    "question": "What is the unique id of the set that has the highest number of cards?",
    "evidence": "the highest number of cards refers to MAX(baseSetSize); unique id refers to id",
    "SQLite_query": "SELECT id FROM sets ORDER BY baseSetSize DESC LIMIT 1",
    "Postgres_query": "SELECT \"id\" FROM \"sets\" ORDER BY \"baseSetSize\" DESC LIMIT 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 510,
    "difficulty": "simple",
    "question": "Among the cards that doesn't have multiple faces on the same card, who is the illustrator of the card art that has the highest cost of converted mana?",
    "evidence": "doesn't have multiple faces refers to side IS NULL; illustrator refers to artist",
    "SQLite_query": "SELECT artist FROM cards WHERE side IS NULL ORDER BY convertedManaCost DESC LIMIT 1",
    "Postgres_query": "SELECT \"artist\" FROM \"cards\" WHERE \"side\" IS NULL ORDER BY \"convertedManaCost\" DESC NULLS LAST LIMIT 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 511,
    "difficulty": "moderate",
    "question": "What is the most common visual frame effects among the incredibly powerful foils?",
    "evidence": "when both cardKingdomFoilId and cardKingdomId are not null, this foil is incredibly powerful; most common visual frame effects refers to MAX(frameEffects)",
    "SQLite_query": "SELECT frameEffects FROM cards WHERE cardKingdomFoilId IS NOT NULL AND cardKingdomId IS NOT NULL GROUP BY frameEffects ORDER BY COUNT(frameEffects) DESC LIMIT 1",
    "Postgres_query": "SELECT \"frameEffects\" FROM \"cards\" WHERE \"cardKingdomFoilId\" IS NOT NULL AND \"cardKingdomId\" IS NOT NULL GROUP BY \"frameEffects\" ORDER BY count(\"frameEffects\") DESC NULLS LAST LIMIT 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 512,
    "difficulty": "simple",
    "question": "How many cards with unknown power that can't be found in foil is in duel deck A?",
    "evidence": "unknown power refers to power IS NULL or power = '*'; can't be found in foil refers to hasFoil = 0; duel deck A refers to duelDeck = 'a'",
    "SQLite_query": "SELECT SUM(CASE WHEN power LIKE '%*%' OR power IS NULL THEN 1 ELSE 0 END) FROM cards WHERE hasFoil = 0 AND duelDeck = 'a'",
    "Postgres_query": "SELECT SUM(CASE WHEN \"power\" LIKE '%*%' OR \"power\" IS NULL THEN 1 ELSE 0 END) FROM \"cards\" WHERE \"hasFoil\" = 0 AND \"duelDeck\" = 'a'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 513,
    "difficulty": "challenging",
    "question": "Among the sets whose expansion type is Commander, which set has the highest total number of cards including promotional and related supplemental products but excluding Alchemy modifications? Indicate the id of the set.",
    "evidence": "expansion type refers to type where type = 'commander'; totalSetSize: The total number of cards in the set, including promotional and related supplemental products but excluding Alchemy modifications; highest total number of cards refers to MAX(totalSetSize)",
    "SQLite_query": "SELECT id FROM sets WHERE type = 'commander' ORDER BY totalSetSize DESC LIMIT 1",
    "Postgres_query": "SELECT \"id\" FROM \"sets\" WHERE \"type\" = 'commander' ORDER BY \"totalSetSize\" DESC LIMIT 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 514,
    "difficulty": "simple",
    "question": "In duels, what are the top 10 cards with the highest uncoverted mana cost?",
    "evidence": "duels refer to format = 'duel'; the highest uncoverted mana cost refers to MAX(manaCost)",
    "SQLite_query": "SELECT DISTINCT name FROM cards WHERE uuid IN ( SELECT uuid FROM legalities WHERE format = 'duel' ) ORDER BY manaCost DESC LIMIT 0, 10",
    "Postgres_query": "SELECT DISTINCT \"name\" FROM \"cards\" WHERE \"uuid\" IN ( SELECT \"uuid\" FROM \"legalities\" WHERE \"format\" = 'duel' ) ORDER BY \"manaCost\" DESC NULLS LAST LIMIT 10",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 515,
    "difficulty": "moderate",
    "question": "When was the oldest mythic card released and what are its legal play formats?",
    "evidence": "the oldest card refers to MIN(originalReleaseDate); mythic card refers to rarity = 'mythic'; legal play refers to status = 'Legal'; play format refers to format",
    "SQLite_query": "SELECT T1.originalReleaseDate, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.rarity = 'mythic' AND T1.originalReleaseDate IS NOT NULL AND T2.status = 'Legal' ORDER BY T1.originalReleaseDate LIMIT 1",
    "Postgres_query": "SELECT \"T1\".\"originalReleaseDate\", \"T2\".\"format\" FROM cards AS \"T1\" INNER JOIN legalities AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"rarity\" = 'mythic' AND \"T1\".\"originalReleaseDate\" IS NOT NULL AND \"T2\".\"status\" = 'Legal' ORDER BY \"T1\".\"originalReleaseDate\" NULLS LAST LIMIT 1",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 516,
    "difficulty": "moderate",
    "question": "How many cards did Volkan Ba\u00c7\u00b5a illustrated whose foreign language is in French?",
    "evidence": "Volkan Ba\u00c7\u00b5a refers to artist = 'Volkan Baga'; foreign language is in French refers to language = 'French'",
    "SQLite_query": "SELECT COUNT(T3.id) FROM ( SELECT T1.id FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Volkan Ba\u01f5a' AND T2.language = 'French' GROUP BY T1.id ) AS T3",
    "Postgres_query": "SELECT count(\"T3\".\"id\") FROM ( SELECT \"T1\".\"id\" FROM \"cards\" AS \"T1\" INNER JOIN \"foreign_data\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"artist\" = 'Volkan Ba\u01f5a' AND \"T2\".\"language\" = 'French' GROUP BY \"T1\".\"id\" ) AS \"T3\"",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 517,
    "difficulty": "moderate",
    "question": "How many rare enchantment Abundance cards are there whose play format status are all legal?",
    "evidence": "rare refers to rarity = 'rare'; enchantment card refers to types = 'Enchantment'; Abundance cards refers to name = 'Abundance'; format status are all legal refers to status = 'Legal'",
    "SQLite_query": "SELECT COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.rarity = 'rare' AND T1.types = 'Enchantment' AND T1.name = 'Abundance' AND T2.status = 'Legal'",
    "Postgres_query": "SELECT COUNT(\"T1\".\"id\") FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"rarity\" = 'rare' AND \"T1\".\"types\" = 'Enchantment' AND \"T1\".\"name\" = 'Abundance' AND \"T2\".\"status\" = 'Legal'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 518,
    "difficulty": "moderate",
    "question": "Which of the play formats has the highest number of banned status? Indicate the play format and the name of the card.",
    "evidence": "play format refers to format uuid; banned status refers to status = 'Banned'; the highest number of banned status refers to MAX(status = 'Banned')",
    "SQLite_query": "SELECT T2.format, T1.name FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T2.status = 'Banned' GROUP BY T2.format ORDER BY COUNT(T2.status) DESC LIMIT 1",
    "Postgres_query": "SELECT \"T2\".\"format\", \"T1\".\"name\" FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T2\".\"status\" = 'Banned' GROUP BY \"T2\".\"format\" ORDER BY count(\"T2\".\"status\") DESC NULLS LAST LIMIT 1",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 519,
    "difficulty": "simple",
    "question": "What is the language of the \"Battlebond\" set?",
    "evidence": "\"Battlebond\" set refers to name = 'Battlebond'",
    "SQLite_query": "SELECT language FROM set_translations WHERE id IN ( SELECT id FROM sets WHERE name = 'Battlebond' )",
    "Postgres_query": "SELECT \"language\" FROM \"set_translations\" WHERE \"id\" IN ( SELECT \"id\" FROM \"sets\" WHERE \"name\" = 'Battlebond' )",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 520,
    "difficulty": "moderate",
    "question": "Who is the illustrator that illustrated the least amount of cards? List the format of play of the cards that he/she illustrated.",
    "evidence": "format of the cards refers to format; illustrator refers to artist; the least amount of cards refers to MIN(artist)",
    "SQLite_query": "SELECT T1.artist, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid GROUP BY T1.artist ORDER BY COUNT(T1.id) ASC LIMIT 1",
    "Postgres_query": "SELECT \"T1\".\"artist\", \"T2\".\"format\" FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" GROUP BY \"T1\".\"artist\" ORDER BY count(\"T1\".\"id\") ASC NULLS LAST LIMIT 1",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 521,
    "difficulty": "challenging",
    "question": "Among the cards whose version of frame style is 1997, what is the status of the card illustrated by D. Alexander Gregory in legacy play format that has sensitive content or Wizards of the Coast?",
    "evidence": "version of frame style is 1997 refers to frameVersion = '1997'; illustrated by D. Alexander Gregory refers to artist = 'D. Alexander Gregory'; sensitive content refers to hasContentWarning = 1; legacy play format refers to format = 'legacy'; status of the card refers to status",
    "SQLite_query": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.frameVersion = 1997 AND T1.hasContentWarning = 1 AND T1.artist = 'D. Alexander Gregory' AND T2.format = 'legacy'",
    "Postgres_query": "SELECT DISTINCT \"T2\".\"status\" FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"frameVersion\" = 1997 AND \"T1\".\"hasContentWarning\" = 1 AND \"T1\".\"artist\" = 'D. Alexander Gregory' AND \"T2\".\"format\" = 'legacy'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 522,
    "difficulty": "moderate",
    "question": "Which cards are ranked 1st on EDHRec? List all of the cards name and its banned play format.",
    "evidence": "ranked 1st on EDHRec refers to edhrecRank = 1; banned refers to status = 'Banned'; play format refers to format; cards name refers to name",
    "SQLite_query": "SELECT T1.name, T2.format FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.edhrecRank = 1 AND T2.status = 'Banned' GROUP BY T1.name, T2.format",
    "Postgres_query": "SELECT \"T1\".\"name\", \"T2\".\"format\" FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"edhrecRank\" = 1 AND \"T2\".\"status\" = 'Banned' GROUP BY \"T1\".\"name\", \"T2\".\"format\"",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 523,
    "difficulty": "challenging",
    "question": "What is the annual average number of sets that were released between 1/1/2012 to 12/31/2015? Indicate the common langugage of the card.",
    "evidence": "AVG(id); releaseDate BETWEEN 1/1/2012 AND 12/31/2015; the common language refers to MAX(COUNT(language))",
    "SQLite_query": "SELECT (CAST(SUM(T1.id) AS REAL) / COUNT(T1.id)) / 4, T2.language FROM sets AS T1 INNER JOIN set_translations AS T2 ON T1.id = T2.id WHERE T1.releaseDate BETWEEN '2012-01-01' AND '2015-12-31' GROUP BY T1.releaseDate ORDER BY COUNT(T2.language) DESC LIMIT 1",
    "Postgres_query": "SELECT (CAST(SUM(\"T1\".\"id\") AS NUMERIC) / COUNT(\"T1\".\"id\")) / 4, \"T2\".\"language\" FROM sets AS \"T1\" INNER JOIN set_translations AS \"T2\" ON \"T1\".\"id\" = \"T2\".\"id\" WHERE \"T1\".\"releaseDate\" BETWEEN '2012-01-01' AND '2015-12-31' GROUP BY \"T1\".\"releaseDate\" ORDER BY COUNT(\"T2\".\"language\") DESC NULLS LAST LIMIT 1",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 524,
    "difficulty": "simple",
    "question": "List the artists who illustrated cards with black borders which are available only in arena.",
    "evidence": "black borders refers to BorderColor = 'black'; available only in arena refers to availability = 'arena'",
    "SQLite_query": "SELECT DISTINCT artist FROM cards WHERE availability = 'arena' AND BorderColor = 'black'",
    "Postgres_query": "SELECT DISTINCT \"artist\" FROM \"cards\" WHERE \"availability\" = 'arena' AND \"BorderColor\" = 'black'",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 525,
    "difficulty": "simple",
    "question": "Find the uuid of cards in which the old school format is restricted or banned.",
    "evidence": "old school format refers to format = 'oldschool'; restricted or banned refers to status = 'Banned' or 'Restricted'",
    "SQLite_query": "SELECT uuid FROM legalities WHERE format = 'oldschool' AND (status = 'Banned' OR status = 'Restricted')",
    "Postgres_query": "SELECT \"uuid\" FROM \"legalities\" WHERE \"format\" = 'oldschool' AND (\"status\" = 'Banned' OR \"status\" = 'Restricted')",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 526,
    "difficulty": "simple",
    "question": "Among the card designed by Matthew D. Wilson, how many are available only in the paper?",
    "evidence": "card designed by Matthew D. Wilson refers to artist = 'Matthew D. Wilson'; available only in the paper refers to availability = 'paper'",
    "SQLite_query": "SELECT COUNT(id) FROM cards WHERE artist = 'Matthew D. Wilson' AND availability = 'paper'",
    "Postgres_query": "SELECT COUNT(\"id\") FROM \"cards\" WHERE \"artist\" = 'Matthew D. Wilson' AND \"availability\" = 'paper'",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 527,
    "difficulty": "moderate",
    "question": "What are the rulings for the card named and designed by Kev Walker? List them in descending order of dates.",
    "evidence": "rulings refers to text; card named and designed by Kev Walker refers to artist = 'Kev Walker'; descending order of dates refers to MAX(date);",
    "SQLite_query": "SELECT T2.text FROM cards AS T1 INNER JOIN rulings AS T2 ON T2.uuid = T1.uuid WHERE T1.artist = 'Kev Walker' ORDER BY T2.date DESC",
    "Postgres_query": "SELECT \"T2\".\"text\" FROM \"cards\" AS \"T1\" INNER JOIN \"rulings\" AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T1\".\"artist\" = 'Kev Walker' ORDER BY \"T2\".\"date\" DESC NULLS LAST",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 528,
    "difficulty": "challenging",
    "question": "List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.",
    "evidence": "the set Hour of Devastation refers to set.name = 'Hour of Devastation'; names of all the cards in the set refers to cards.name; legal cards refers to status = 'Legal'; the formats refers to format",
    "SQLite_query": "SELECT DISTINCT T2.name , CASE WHEN T1.status = 'Legal' THEN T1.format ELSE NULL END FROM legalities AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid WHERE T2.setCode IN ( SELECT code FROM sets WHERE name = 'Hour of Devastation' )",
    "Postgres_query": "SELECT DISTINCT \"T2\".\"name\" , CASE WHEN \"T1\".\"status\" = 'Legal' THEN \"T1\".\"format\" ELSE NULL END FROM legalities AS \"T1\" INNER JOIN cards AS \"T2\" ON \"T2\".\"uuid\" = \"T1\".\"uuid\" WHERE \"T2\".\"setCode\" IN ( SELECT \"code\" FROM sets WHERE \"name\" = 'Hour of Devastation' )",
    "result_matched": false
  },
  {
    "db_id": "card_games",
    "question_id": 529,
    "difficulty": "moderate",
    "question": "Find and list the names of sets which doesn't have Japanese translation but have Korean translation.",
    "evidence": "names of sets refers to name; doesn't have Japanese translation refers to language not like '%Japanese%'; have Korean translation refers to language = 'Korean'",
    "SQLite_query": "SELECT name FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Korean' AND language NOT LIKE '%Japanese%' )",
    "Postgres_query": "SELECT \"name\" FROM \"sets\" WHERE \"code\" IN ( SELECT \"setCode\" FROM \"set_translations\" WHERE \"language\" = 'Korean' AND \"language\" NOT ILIKE '%Japanese%' )",
    "result_matched": true
  },
  {
    "db_id": "card_games",
    "question_id": 530,
    "difficulty": "moderate",
    "question": "List all the frame styles and cards Allen Williams worked on and find any banned cards if there are any.",
    "evidence": "frame styles refers to frameVersion; cards Allen Williams worked on refers to artist = 'Allen Williams'; banned cards refers to status = 'Banned'",
    "SQLite_query": "SELECT DISTINCT T1.frameVersion, T1.name , IIF(T2.status = 'Banned', T1.name, 'NO') FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T1.artist = 'Allen Williams'",
    "Postgres_query": "SELECT DISTINCT \"T1\".\"frameVersion\", \"T1\".\"name\" , CASE WHEN \"T2\".\"status\" = 'Banned' THEN \"T1\".\"name\" ELSE 'NO' END FROM \"cards\" AS \"T1\" INNER JOIN \"legalities\" AS \"T2\" ON \"T1\".\"uuid\" = \"T2\".\"uuid\" WHERE \"T1\".\"artist\" = 'Allen Williams'",
    "result_matched": false
  }
]