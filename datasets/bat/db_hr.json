[
    {
      "id": 1,
      "nl_prompt": "Who are the newest employees for each department to join the company and their manager?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          "WITH NewestEmployees AS ( SELECT e.employee_id, e.first_name, e.last_name, e.department_id, e.manager_id, e.hire_date, ROW_NUMBER() OVER (PARTITION BY e.department_id ORDER BY e.hire_date DESC) AS rn FROM employee e ) SELECT ne.employee_id, ne.first_name, ne.last_name, ne.department_id, ne.manager_id, ne.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name FROM NewestEmployees ne JOIN employee m ON ne.employee_id = m.employee_id WHERE ne.rn = 1;"
        ]
      },
      "eval_query": {
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "JOIN",
        "RANK",
        "SORT",
        "WITH"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 2,
      "nl_prompt": "How many employees have been hired each year and there avg salary?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT EXTRACT(YEAR FROM hire_date) AS hire_year, COUNT(*) AS total_hired, AVG(salary) AS avg_salary FROM employee JOIN salary ON employee.employee_id = salary.employee_id GROUP BY EXTRACT(YEAR FROM hire_date);"
        ],
        "mysql": [
          "SELECT YEAR(hire_date) AS hire_year, COUNT(*) AS total_hired, AVG(salary) AS avg_salary FROM employee JOIN salary ON employee.employee_id = salary.employee_id GROUP BY YEAR(hire_date);"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 3,
      "nl_prompt": "What is the average salary in the company based on hired date?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          "SELECT YEAR(hire_date) AS hire_year, COUNT(*) AS total_hired, AVG(salary) AS avg_salary FROM employee JOIN salary ON employee.employee_id = salary.employee_id GROUP BY YEAR(hire_date);"
        ]
      },
      "eval_query": {
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 4,
      "nl_prompt": "Retrieve the list of employees who are currently on leave, including their names, the start and end dates of their leave, and the number of days left for each employee's leave. Provide this information for all employees who have a leave period that includes today's date.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.first_name, e.last_name, lr.start_date, lr.end_date, (lr.end_date - CURRENT_DATE) AS days_left FROM employee e JOIN leave_request lr ON e.employee_id = lr.employee_id WHERE '2023-01-03' BETWEEN lr.start_date AND lr.end_date;"
        ],
        "mysql": [
          "SELECT e.first_name, e.last_name, lr.start_date, lr.end_date, DATEDIFF(lr.end_date, CURDATE()) AS days_left FROM employee e JOIN leave_request lr ON e.employee_id = lr.employee_id WHERE '2023-01-03' BETWEEN lr.start_date AND lr.end_date;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "DATE",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 5,
      "nl_prompt": "What are the top 5 employees that have more benefits from last year?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, COUNT(*) AS total_benefits FROM employee e JOIN employee_x_benefit xb ON e.employee_id = xb.employee_id WHERE YEAR(xb.start_date) = YEAR(CURRENT_DATE() - INTERVAL 2 YEAR) GROUP BY e.employee_id, e.first_name, e.last_name ORDER BY total_benefits DESC LIMIT 5;"
        ]
      },
      "eval_query": {
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "DATE",
        "JOIN",
        "AGGREGATE",
        "SORT",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 6,
      "nl_prompt": "Which employee has the most certifications?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, COUNT(*) AS total_certifications FROM employee_certification GROUP BY employee_id ORDER BY total_certifications DESC LIMIT 1;"
        ],
        "mysql": [
          "SELECT employee_id, COUNT(*) AS total_certifications FROM employee_certification GROUP BY employee_id ORDER BY total_certifications DESC LIMIT 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE",
        "SORT",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 7,
      "nl_prompt": "How many employees have received a performance review this year?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT COUNT(DISTINCT pr.employee_id) AS total_employees_reviewed FROM performance_review pr JOIN employee e ON pr.employee_id = e.employee_id WHERE EXTRACT(YEAR FROM pr.review_date) = EXTRACT(YEAR FROM CURRENT_DATE);"
        ],
        "mysql": [
          "SELECT COUNT(DISTINCT pr.employee_id) AS total_employees_reviewed FROM performance_review pr JOIN employee e ON pr.employee_id = e.employee_id WHERE YEAR(pr.review_date) = YEAR(CURDATE());"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 8,
      "nl_prompt": "Which employee has the highest performance rating?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, performance_rating FROM performance_review ORDER BY performance_rating DESC LIMIT 1;"
        ],
        "mysql": [
          "SELECT employee_id, performance_rating FROM performance_review ORDER BY performance_rating DESC LIMIT 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "SORT",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 9,
      "nl_prompt": "Which employee has the oldest assigned laptop?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, ec.computer_name, ec.serial_number, ec.model, ec.purchase_date FROM employee_computer ec JOIN employee e ON ec.employee_id = e.employee_id WHERE ec.purchase_date = ( SELECT MIN(purchase_date) FROM employee_computer );"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, ec.computer_name, ec.serial_number, ec.model, ec.purchase_date FROM employee_computer ec JOIN employee e ON ec.employee_id = e.employee_id WHERE ec.purchase_date = ( SELECT MIN(purchase_date) FROM employee_computer );"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 10,
      "nl_prompt": "Which department has the highest employee turnover rate?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "WITH TurnoverRates AS ( SELECT department_id, COUNT(*) AS total_employees, SUM(CASE WHEN termination_date IS NOT NULL THEN 1 ELSE 0 END) AS terminated_employees, CAST(SUM(CASE WHEN termination_date IS NOT NULL THEN 1 ELSE 0 END) AS NUMERIC) / COUNT(*) AS turnover_rate FROM employee a LEFT JOIN employee_termination b ON a.employee_id = b.employee_id GROUP BY department_id ) SELECT * FROM TurnoverRates ORDER BY turnover_rate DESC LIMIT 1;"
        ],
        "mysql": [
          "SELECT department_id, COUNT(*) AS total_employees, SUM(CASE WHEN termination_date IS NOT NULL THEN 1 ELSE 0 END) AS terminated_employees, SUM(CASE WHEN termination_date IS NOT NULL THEN 1 ELSE 0 END) / COUNT(*) AS turnover_rate FROM employee a, employee_termination b WHERE a.employee_id = b.employee_id GROUP BY department_id ORDER BY turnover_rate DESC LIMIT 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "SORT",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 11,
      "nl_prompt": "How many employees have been promoted this year?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT COUNT(*) AS total_promotions FROM job_history WHERE start_date >= '2020-01-01' AND start_date < '2021-01-01'"
        ],
        "mysql": [
          "SELECT COUNT(*) AS total_promotions FROM job_history WHERE start_date >= '2020-01-01' AND start_date < '2021-01-01';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Extra context": "start_date >= '2024-01-01' AND start_date < '2025-01-01'"
      }
    },
    {
      "id": 12,
      "nl_prompt": "Which employee has the most job changes within the company?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "WITH EmployeeJobChanges AS ( SELECT employee_id, COUNT(*) AS total_job_changes FROM job_history GROUP BY employee_id ORDER BY total_job_changes DESC LIMIT 1 ) SELECT jh.employee_id, e.first_name, e.last_name, e.email, ejc.total_job_changes, j.job_title, jh.job_id, jh.start_date, jh.end_date FROM EmployeeJobChanges ejc JOIN employee e ON ejc.employee_id = e.employee_id JOIN job_history jh ON ejc.employee_id = jh.employee_id JOIN job j ON jh.job_id = j.job_id ;"
        ],
        "mysql": [
          "WITH EmployeeJobChanges AS ( SELECT employee_id, COUNT(*) AS total_job_changes FROM job_history GROUP BY employee_id ORDER BY total_job_changes DESC LIMIT 1 ) SELECT jh.employee_id, e.first_name, e.last_name, e.email, ejc.total_job_changes, j.job_title, jh.job_id, jh.start_date, jh.end_date FROM EmployeeJobChanges ejc JOIN employee e ON ejc.employee_id = e.employee_id JOIN job_history jh ON ejc.employee_id = jh.employee_id JOIN job j ON jh.job_id = j.job_id ;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "SORT",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 13,
      "nl_prompt": "What is the average tenure of employees in each department?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT department_id, AVG(EXTRACT(DAY FROM (NOW() - hire_date))) AS avg_tenure_days FROM employee GROUP BY department_id;"
        ],
        "mysql": [
          "SELECT department_id, AVG(DATEDIFF(NOW(), hire_date)) AS avg_tenure_days FROM employee GROUP BY department_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 14,
      "nl_prompt": "How many employees are eligible for retirement within the next five years?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          "SELECT COUNT(*) AS total_eligible_for_retirement FROM employee WHERE DATE_ADD(date_of_birth, INTERVAL 65 YEAR) <= DATE_ADD(NOW(), INTERVAL 30 YEAR);"
        ]
      },
      "eval_query": {
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Extra context": "Retirement age = 65",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 15,
      "nl_prompt": "Which department has the highest average performance rating?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT department_id, AVG(performance_rating) AS avg_performance_rating FROM performance_review JOIN employee ON performance_review.employee_id = employee.employee_id GROUP BY department_id ORDER BY avg_performance_rating DESC LIMIT 1;"
        ],
        "mysql": [
          "SELECT department_id, AVG(performance_rating) AS avg_performance_rating FROM performance_review JOIN employee ON performance_review.employee_id = employee.employee_id GROUP BY department_id ORDER BY avg_performance_rating DESC LIMIT 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "SORT",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 16,
      "nl_prompt": "What is the total cost of salaries for all employees in each department?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT d.department_id, d.department_name, SUM(s.salary) AS total_salary_cost FROM salary s JOIN employee e ON s.employee_id = e.employee_id JOIN department d ON e.department_id = d.department_id GROUP BY d.department_id, d.department_name;"
        ],
        "mysql": [
          "SELECT d.department_id, d.department_name, SUM(s.salary) AS total_salary_cost FROM salary s JOIN employee e ON s.employee_id = e.employee_id JOIN department d ON e.department_id = d.department_id GROUP BY d.department_id, d.department_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 17,
      "nl_prompt": "How many employees have completed mandatory compliance training?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT COUNT(DISTINCT employee_id) AS total_completed_compliance_training FROM employee_training WHERE training_id IN ( SELECT training_id FROM training WHERE attendance_required = true );"
        ],
        "mysql": [
          "SELECT COUNT(DISTINCT employee_id) AS total_completed_compliance_training FROM employee_training WHERE training_id IN ( SELECT training_id FROM training WHERE attendance_required =1 );"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 18,
      "nl_prompt": "Which department has the highest average attendance at training sessions?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT d.department_id, d.department_name, AVG(b.end_date - b.start_date) AS avg_attendance FROM training a JOIN employee_training b ON a.training_id = b.training_id JOIN employee c ON b.employee_id = c.employee_id JOIN department d ON c.department_id = d.department_id GROUP BY d.department_id, d.department_name;"
        ],
        "mysql": [
          "select d.department_id ,d.department_name, AVG(b.end_date - b.start_date) as avg_attendance from training a, employee_training b , employee c , department d where a.training_id = b.training_id AND b.employee_id = c.employee_id AND d.department_id = c.department_id group by d.department_id, d.department_name ;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 19,
      "nl_prompt": "What is the total cost of benefits for each department?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT d.department_id, d.department_name, SUM(budget) AS total_benefit_cost FROM benefit b JOIN employee_x_benefit eb ON b.benefit_id = eb.benefit_id JOIN employee e ON eb.employee_id = e.employee_id JOIN department d ON e.department_id = d.department_id GROUP BY d.department_id, d.department_name;"
        ],
        "mysql": [
          "SELECT d.department_id, d.department_name, SUM(d.budget) AS total_benefit_cost FROM benefit b JOIN employee_x_benefit eb ON b.benefit_id = eb.benefit_id JOIN employee e ON eb.employee_id = e.employee_id JOIN department d ON e.department_id = d.department_id GROUP BY d.department_id, d.department_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 20,
      "nl_prompt": "Could you provide a split of 5 age groups and the average salary for each group?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "WITH AgeGroups AS ( SELECT employee_id, FLOOR(EXTRACT(EPOCH FROM AGE(NOW(), date_of_birth)) / 31556952) AS age, salary FROM employee JOIN salary USING (employee_id) ) SELECT CASE WHEN age BETWEEN 18 AND 30 THEN '18-30' WHEN age BETWEEN 31 AND 40 THEN '31-40' WHEN age BETWEEN 41 AND 50 THEN '41-50' WHEN age BETWEEN 51 AND 60 THEN '51-60' ELSE 'Over 60' END AS age_group, AVG(salary) AS avg_salary FROM AgeGroups GROUP BY age_group ORDER BY MIN(age);"
        ],
        "mysql": [
          "WITH AgeGroups AS ( SELECT employee_id, FLOOR(DATEDIFF(CURDATE(), date_of_birth) / 365) AS age, salary FROM employee JOIN salary USING (employee_id) ) SELECT CASE WHEN age BETWEEN 18 AND 30 THEN '18-30' WHEN age BETWEEN 31 AND 40 THEN '31-40' WHEN age BETWEEN 41 AND 50 THEN '41-50' WHEN age BETWEEN 51 AND 60 THEN '51-60' ELSE 'Over 60' END AS age_group, AVG(salary) AS avg_salary FROM AgeGroups GROUP BY age_group ORDER BY MIN(age);"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "WITH",
        "JOIN",
        "AGGREGATE",
        "SORT",
        "DATE"
      ],
      "other": {
        "Extra context": "Age groups: WHEN age BETWEEN 18 AND 30 THEN '18-30' WHEN age BETWEEN 31 AND 40 THEN '31-40' WHEN age BETWEEN 41 AND 50 THEN '41-50' WHEN age BETWEEN 51 AND 60 THEN '51-60' ELSE 'Over 60'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 21,
      "nl_prompt": "List the invoices that are overdue, including invoice details.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT i.invoice_id, i.invoice_date, i.total_amount, i.due_date FROM invoice i LEFT JOIN payment p ON i.invoice_id = p.invoice_id WHERE i.due_date < CURRENT_DATE;"
        ],
        "mysql": [
          "SELECT i.invoice_id, i.invoice_date, i.total_amount, i.due_date FROM invoice i LEFT JOIN payment p ON i.invoice_id = p.invoice_id WHERE i.due_date < CURDATE();"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "LEFT_JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 22,
      "nl_prompt": "Calculate the total amount paid each month, including the total amount of invoices issued in that month.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT EXTRACT(YEAR FROM p.payment_date) AS year, EXTRACT(MONTH FROM p.payment_date) AS month, SUM(p.amount) AS total_paid, SUM(i.total_amount) AS total_invoiced FROM payment p JOIN invoice i ON p.invoice_id = i.invoice_id GROUP BY EXTRACT(YEAR FROM p.payment_date), EXTRACT(MONTH FROM p.payment_date) ORDER BY year, month;"
        ],
        "mysql": [
          "SELECT YEAR(p.payment_date) AS year, MONTH(p.payment_date) AS month, SUM(p.amount) AS total_paid, SUM(i.total_amount) AS total_invoiced FROM payment p JOIN invoice i ON p.invoice_id = i.invoice_id GROUP BY YEAR(p.payment_date), MONTH(p.payment_date) ORDER BY year, month;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "JOIN",
        "SORT",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 23,
      "nl_prompt": "Find the total amount paid for each invoice, including invoice details.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT i.invoice_id, i.invoice_date, i.total_amount, SUM(p.amount) AS total_paid FROM invoice i LEFT JOIN payment p ON i.invoice_id = p.invoice_id GROUP BY i.invoice_id, i.invoice_date, i.total_amount;"
        ],
        "mysql": [
          "SELECT i.invoice_id, i.invoice_date, i.total_amount, SUM(p.amount) AS total_paid FROM invoice i LEFT JOIN payment p ON i.invoice_id = p.invoice_id GROUP BY i.invoice_id, i.invoice_date, i.total_amount;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "LEFT_JOIN",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 24,
      "nl_prompt": "List all payments made in the last month, including invoice details (such as invoice number and total amount).",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT p.payment_id, p.payment_date, p.amount, i.invoice_id, i.invoice_date, i.total_amount FROM payment p JOIN invoice i ON p.invoice_id = i.invoice_id WHERE p.payment_date >= CURRENT_DATE - INTERVAL '1 month';"
        ],
        "mysql": [
          "SELECT p.payment_id, p.payment_date, p.amount, i.invoice_id, i.invoice_date, i.total_amount FROM payment p JOIN invoice i ON p.invoice_id = i.invoice_id WHERE p.payment_date >= DATE_SUB(CURDATE(), INTERVAL 1 MONTH);"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 25,
      "nl_prompt": "Add to employee table country_code",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE employee ADD COLUMN country_code VARCHAR(2);"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee' AND column_name = 'country_code';"
        ],
        "mysql": [
          "SELECT COUNT(*) = 1 FROM information_schema.columns WHERE table_name = 'employee' AND column_name = 'country_code';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE employee DROP COLUMN IF EXISTS country_code;"
        ],
        "mysql": [
          "ALTER TABLE employee DROP COLUMN country_code;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE employee DROP COLUMN IF EXISTS country_code;"
        ],
        "mysql": [
          "ALTER TABLE employee DROP COLUMN country_code;"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "ADD_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 26,
      "nl_prompt": "Add created_date and modified_date columns to the attendance table",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE attendance ADD COLUMN created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP, ADD COLUMN modified_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'attendance' AND (column_name = 'created_date' OR column_name = 'modified_date');"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'attendance' AND (column_name = 'created_date' OR column_name = 'modified_date');"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE attendance DROP COLUMN IF EXISTS created_date, DROP COLUMN IF EXISTS modified_date;"
        ],
        "mysql": [
          "DROP PROCEDURE IF EXISTS DropColumnIfExists; DELIMITER // CREATE PROCEDURE DropColumnIfExists(IN tableName VARCHAR(255), IN columnName VARCHAR(255)) BEGIN IF EXISTS ( SELECT * FROM information_schema.columns WHERE table_name = tableName AND column_name = columnName ) THEN SET @sql = CONCAT('ALTER TABLE ', tableName, ' DROP COLUMN ', columnName); PREPARE stmt FROM @sql; EXECUTE stmt; DEALLOCATE PREPARE stmt; END IF; END // DELIMITER ; CALL DropColumnIfExists('attendance', 'created_date'); CALL DropColumnIfExists('attendance', 'modified_date');"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE attendance DROP COLUMN IF EXISTS created_date, DROP COLUMN IF EXISTS modified_date;"
        ],
        "mysql": [
          "DROP PROCEDURE IF EXISTS DropColumnIfExists; ALTER TABLE attendance DROP COLUMN created_date; ALTER TABLE attendance DROP COLUMN modified_date;"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "ADD_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 27,
      "nl_prompt": "Drop the contact_person, contact_email, and contact_phone columns from the company table",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE company DROP COLUMN contact_person, DROP COLUMN contact_email, DROP COLUMN contact_phone;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'company' AND (column_name = 'contact_person' OR column_name = 'contact_email' OR column_name = 'contact_phone');"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'company' AND (column_name = 'contact_person' OR column_name = 'contact_email' OR column_name = 'contact_phone');"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE company ADD COLUMN contact_person VARCHAR(50), ADD COLUMN contact_email VARCHAR(50), ADD COLUMN contact_phone INT;"
        ],
        "mysql": [
          "ALTER TABLE company ADD COLUMN contact_person VARCHAR(50), ADD COLUMN contact_email VARCHAR(50), ADD COLUMN contact_phone INT;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE company ADD COLUMN contact_person VARCHAR(50), ADD COLUMN contact_email VARCHAR(50), ADD COLUMN contact_phone INT;"
        ],
        "mysql": [
          "ALTER TABLE company ADD COLUMN contact_person VARCHAR(50), ADD COLUMN contact_email VARCHAR(50), ADD COLUMN contact_phone INT;"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "DROP_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 28,
      "nl_prompt": "Create an index on employee_termination include termination_date column",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "CREATE INDEX idx_employee_termination_termination_date_employee_id ON employee_termination(termination_date, employee_id);"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM pg_indexes WHERE tablename = 'employee_termination' AND indexname = 'idx_employee_termination_termination_date_employee_id';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM information_schema.statistics WHERE table_name = 'employee_termination' AND index_name = 'idx_employee_termination_termination_date_employee_id';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "DROP INDEX IF EXISTS idx_employee_termination_termination_date_employee_id;"
        ],
        "mysql": [
          "DROP INDEX idx_employee_termination_termination_date_employee_id ON employee_termination;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "DROP INDEX IF EXISTS idx_employee_termination_termination_date_employee_id;"
        ],
        "mysql": [
          "DROP INDEX idx_employee_termination_termination_date_employee_id ON employee_termination;"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "CREATE_INDEX"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 29,
      "nl_prompt": "Modify table employee to add nationality",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE employee ADD COLUMN nationality VARCHAR(255);"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee' AND column_name = 'nationality';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee' AND column_name = 'nationality';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE employee DROP COLUMN IF EXISTS nationality;"
        ],
        "mysql": [
          "ALTER TABLE employee DROP COLUMN nationality;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE employee DROP COLUMN IF EXISTS nationality;"
        ],
        "mysql": [
          "ALTER TABLE employee DROP COLUMN nationality;"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "ADD_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 30,
      "nl_prompt": "Change the data type of the check_in_method and check_out_method columns in the attendance table to CHAR(100)",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE attendance ALTER COLUMN check_in_method TYPE CHAR(100), ALTER COLUMN check_out_method TYPE CHAR(100);"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'attendance' AND (column_name = 'check_in_method' OR column_name = 'check_out_method') AND data_type = 'character varying' AND character_maximum_length = 100;"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'attendance' AND (column_name = 'check_in_method' OR column_name = 'check_out_method') AND data_type = 'character varying' AND character_maximum_length = 100;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE attendance ALTER COLUMN check_in_method TYPE CHAR(100), ALTER COLUMN check_out_method TYPE CHAR(100);"
        ],
        "mysql": [
          "ALTER TABLE attendance MODIFY COLUMN check_in_method CHAR(100), MODIFY COLUMN check_out_method CHAR(100);"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE attendance ALTER COLUMN check_in_method TYPE CHAR(100), ALTER COLUMN check_out_method TYPE CHAR(100);"
        ],
        "mysql": [
          "ALTER TABLE attendance MODIFY COLUMN check_in_method CHAR(100), MODIFY COLUMN check_out_method CHAR(100);"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "ALTER_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 31,
      "nl_prompt": "Update the employee termination records to include the reason for termination.",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE employee_termination ADD COLUMN termination_reason VARCHAR(255);"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee_termination' AND column_name = 'termination_reason';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee_termination' AND column_name = 'termination_reason';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE employee_termination DROP COLUMN IF EXISTS termination_reason;"
        ],
        "mysql": [
          "ALTER TABLE employee_termination DROP COLUMN termination_reason;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE employee_termination DROP COLUMN IF EXISTS termination_reason;"
        ],
        "mysql": [
          "ALTER TABLE employee_termination DROP COLUMN termination_reason;"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "ADD_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 32,
      "nl_prompt": "Remove the national identification numbers from the employee records.",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE employee DROP COLUMN national_identification;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee' AND column_name = 'national_identification';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee' AND column_name = 'national_identification';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE employee ADD COLUMN national_identification VARCHAR(255);"
        ],
        "mysql": [
          "ALTER TABLE employee ADD COLUMN national_identification VARCHAR(255);"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE employee ADD COLUMN national_identification VARCHAR(255);"
        ],
        "mysql": [
          "ALTER TABLE employee ADD COLUMN national_identification VARCHAR(255);"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "DROP_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 33,
      "nl_prompt": "Update the training records to include the duration of each training session.",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE employee_training ADD COLUMN duration INT;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee_training' AND column_name = 'duration';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee_training' AND column_name = 'duration';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE employee_training DROP COLUMN IF EXISTS duration;"
        ],
        "mysql": [
          "ALTER TABLE employee_training DROP COLUMN duration;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE employee_training DROP COLUMN IF EXISTS duration;"
        ],
        "mysql": [
          "ALTER TABLE employee_training DROP COLUMN duration;"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "ADD_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 34,
      "nl_prompt": "Set a default status for new leave requests.",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE leave_request ALTER COLUMN status SET DEFAULT 'Pending';"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT column_default FROM information_schema.columns WHERE table_name = 'leave_request' AND column_name = 'status';"
        ],
        "mysql": [
          "SELECT column_default FROM information_schema.columns WHERE table_name = 'leave_request' AND column_name = 'status';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE leave_request ALTER COLUMN status SET DEFAULT 'Pending';"
        ],
        "mysql": [
          "ALTER TABLE leave_request ALTER COLUMN status SET DEFAULT 'Pending';"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE leave_request ALTER COLUMN status SET DEFAULT 'Pending';"
        ],
        "mysql": [
          "ALTER TABLE leave_request ALTER COLUMN status SET DEFAULT 'Pending';"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "ADD_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 35,
      "nl_prompt": "Update a job's title.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE job SET job_title = 'Human Resources Manager' WHERE job_id = 1;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM job WHERE job_id = 1 AND job_title = 'Human Resources Manager';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM job WHERE job_id = 1 AND job_title = 'Human Resources Manager';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE job SET job_title = 'Software Engineer' WHERE job_id = 1;"
        ],
        "mysql": [
          "UPDATE job SET job_title = 'Software Engineer' WHERE job_id = 1;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE job SET job_title = 'Software Engineer' WHERE job_id = 1;"
        ],
        "mysql": [
          "UPDATE job SET job_title = 'Software Engineer' WHERE job_id = 1;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "job_id =1",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 36,
      "nl_prompt": "Delete a department record.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "mysql": [
          "SELECT COUNT(*) FROM department WHERE department_id = 1;"
        ]
      },
      "setup_sql": {
        "mysql": [
          "INSERT INTO department VALUES (1, 'Human Resources', '3536251', '100000.00', '2023-01-01', NULL, '1', '{\"goal1\": \"Recruit top talent\", \"goal2\": \"Employee development\"}', '{\"achievement1\": \"Increased employee satisfaction by 20%\", \"achievement2\": \"Reduced turnover rate by 15%\"}', '1');"
        ]
      },
      "cleanup_sql": {
        "mysql": [
          "INSERT INTO department VALUES (1, 'Human Resources', '3536251', '100000.00', '2023-01-01', NULL, '1', '{\"goal1\": \"Recruit top talent\", \"goal2\": \"Employee development\"}', '{\"achievement1\": \"Increased employee satisfaction by 20%\", \"achievement2\": \"Reduced turnover rate by 15%\"}', '1');"
        ]
      },
      "tags": [
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "DELETE"
      ],
      "other": {
        "Extra context": "department_id =1",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 37,
      "nl_prompt": "Insert a new job record.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE job DISABLE TRIGGER ALL; INSERT INTO job (job_id, job_title, department_id, min_salary, max_salary) VALUES (100, 'HR Manager', 100, 50000, 80000); ALTER TABLE job enable TRIGGER ALL;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM job WHERE job_id = 100 AND job_title = 'HR Manager' AND department_id = 100 AND min_salary = 50000 AND max_salary = 80000;"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM job WHERE job_id = 100 AND job_title = 'HR Manager' AND department_id = 100 AND min_salary = 50000 AND max_salary = 80000;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "DELETE FROM job WHERE job_id = 100"
        ],
        "mysql": []
      },
      "cleanup_sql": {
        "postgres": [
          "DELETE FROM job WHERE job_id = 100"
        ],
        "mysql": [
          "DELETE FROM job WHERE job_id = 100"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "INSERT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 38,
      "nl_prompt": "Insert a new attendance record",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE attendance DISABLE TRIGGER ALL; INSERT INTO attendance (attendance_id, employee_id, date, check_in_time, check_out_time) VALUES (100, 100, '2022-02-01', '09:00:00', '17:00:00'); ALTER TABLE attendance enable TRIGGER ALL;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM attendance WHERE attendance_id = 100 AND employee_id = 100 AND date = '2022-02-01' AND check_in_time = '09:00:00' AND check_out_time = '17:00:00';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM attendance WHERE attendance_id = 100 AND employee_id = 100 AND date = '2022-02-01' AND check_in_time = '09:00:00' AND check_out_time = '17:00:00';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "DELETE FROM attendance WHERE attendance_id = 100"
        ],
        "mysql": []
      },
      "cleanup_sql": {
        "postgres": [
          "DELETE FROM attendance WHERE attendance_id = 100"
        ],
        "mysql": [
          "DELETE FROM attendance WHERE attendance_id = 100"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "INSERT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 39,
      "nl_prompt": "Update a department's name.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE department SET department_name = 'Human Resources' WHERE department_id = 1;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM department WHERE department_id = 1 AND department_name = 'Human Resources';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM department WHERE department_id = 1 AND department_name = 'Human Resources';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE department SET department_name = 'Human Resources' WHERE department_id = 1;"
        ],
        "mysql": [
          "UPDATE department SET department_name = 'Human Resources' WHERE department_id = 1;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE department SET department_name = 'Human Resources' WHERE department_id = 1;"
        ],
        "mysql": [
          "UPDATE department SET department_name = 'Human Resources' WHERE department_id = 1;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "department_id =1",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 40,
      "nl_prompt": "Update an employee's phone number.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee SET phone_number = '987-654-3210' WHERE employee_id = 1;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM employee WHERE employee_id = 1 AND phone_number = '987-654-3210';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM employee WHERE employee_id = 3536251 AND phone_number = '987-654-3210';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee SET phone_number = '123-456-7890' WHERE employee_id = 3536251;"
        ],
        "mysql": [
          "UPDATE employee SET phone_number = '123-456-7890' WHERE employee_id = 3536251;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee SET phone_number = '123-456-7890' WHERE employee_id = 3536251;"
        ],
        "mysql": [
          "UPDATE employee SET phone_number = '123-456-7890' WHERE employee_id = 3536251;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "department_id =1",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 41,
      "nl_prompt": "Insert a new employee record.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "INSERT INTO employee (employee_id, first_name, last_name, email, phone_number, hire_date, department_id, job_id, manager_id, company_id) VALUES (1, 'John', 'Doe', 'john.doe@example.com', '123-456-7890', '2022-01-01', 1, 1, NULL, 1);"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM employee WHERE employee_id = 1 AND first_name = 'John' AND last_name = 'Doe' AND email = 'john.doe@example.com' AND phone_number = '123-456-7890' AND hire_date = '2022-01-01' AND department_id = 1 AND job_id = 1 AND manager_id IS NULL AND company_id = 1;"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM employee WHERE employee_id = 1 AND first_name = 'John' AND last_name = 'Doe' AND email = 'john.doe@example.com' AND phone_number = '123-456-7890' AND hire_date = '2022-01-01' AND department_id = 1 AND job_id = 1 AND manager_id IS NULL AND company_id = 1;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE employee DISABLE TRIGGER ALL; DELETE FROM employee WHERE employee_id = 1; ALTER TABLE employee ENABLE TRIGGER ALL;"
        ],
        "mysql": []
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE employee DISABLE TRIGGER ALL; DELETE FROM employee WHERE employee_id = 1; ALTER TABLE employee ENABLE TRIGGER ALL;"
        ],
        "mysql": [
          "DELETE FROM employee WHERE employee_id = 1"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "INSERT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 42,
      "nl_prompt": "Add a new employee with only adress field",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE attendance DISABLE TRIGGER ALL; INSERT INTO employee (employee_id, address) VALUES (10001, '{\"street\": \"123 Main St\", \"city\": \"Anytown\", \"zipcode\": \"12345\"}'); ALTER TABLE attendance enable TRIGGER ALL;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM employee WHERE employee_id = 1 AND address = '{\"street\": \"123 Main St\", \"city\": \"Anytown\", \"zipcode\": \"12345\"}'::jsonb;"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM employee WHERE employee_id = 101 AND JSON_EXTRACT(address, '$.city') = 'Anytown';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "DELETE FROM employee WHERE employee_id = 101"
        ],
        "mysql": []
      },
      "cleanup_sql": {
        "postgres": [
          "DELETE FROM employee WHERE employee_id = 101"
        ],
        "mysql": [
          "DELETE FROM employee WHERE employee_id = 101"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "INSERT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 43,
      "nl_prompt": "Update adress field",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee SET address = '{\"street\": \"456 Elm St\", \"city\": \"Othertown\", \"zipcode\": \"54321\"}' WHERE employee_id = 1;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "\"SELECT * FROM employee WHERE employee_id = 1;\""
        ],
        "mysql": [
          "SELECT COUNT(*) FROM employee WHERE employee_id = 3536251 AND JSON_EXTRACT(address, '$.city') = 'Othertown';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee SET address = '{\"zip\": \"12345\", \"city\": \"Anytown\", \"state\": \"CA\", \"street\": \"123 Main St\"}' WHERE employee_id = 3536251;"
        ],
        "mysql": [
          "UPDATE employee SET address = '{\"zip\": \"12345\", \"city\": \"Anytown\", \"state\": \"CA\", \"street\": \"123 Main St\"}' WHERE employee_id = 3536251;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee SET address = '{\"zip\": \"12345\", \"city\": \"Anytown\", \"state\": \"CA\", \"street\": \"123 Main St\"}' WHERE employee_id = 3536251;"
        ],
        "mysql": [
          "UPDATE employee SET address = '{\"zip\": \"12345\", \"city\": \"Anytown\", \"state\": \"CA\", \"street\": \"123 Main St\"}' WHERE employee_id = 3536251;"
        ]
      },
      "tags": [
        "DML",
        "difficulty: simple",
        "UPDATE",
        "experience: Generation",
        "cuj: query"
      ],
      "other": {
        "Extra context": "department_id =1",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 44,
      "nl_prompt": "Determine the average number of days taken for employees to return company-owned computers after termination, categorized by the reason for termination.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT et.reason, AVG(ec.returned_date - et.termination_date) AS avg_return_days FROM employee_termination et JOIN employee_computer ec ON et.employee_id = ec.employee_id WHERE ec.returned_date IS NOT NULL GROUP BY et.reason;"
        ],
        "mysql": [
          "SELECT et.reason, AVG(DATEDIFF(ec.returned_date, et.termination_date)) AS avg_return_days FROM employee_termination et JOIN employee_computer ec ON et.employee_id = ec.employee_id WHERE ec.returned_date IS NOT NULL GROUP BY et.reason;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 45,
      "nl_prompt": "Find the employees who have received bonuses exceeding $5000 in the last quarter, along with the total bonus amount received by each employee.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, SUM(bonus) AS total_bonus_amount FROM employee e JOIN salary s ON e.employee_id = s.employee_id WHERE s.start_date >= CURRENT_DATE - INTERVAL '3 months' AND bonus > 5000 GROUP BY e.employee_id, e.first_name;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, SUM(bonus) AS total_bonus_amount FROM employee e JOIN salary s ON e.employee_id = s.employee_id WHERE s.start_date >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH) AND bonus > 5000 GROUP BY e.employee_id, e.first_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Extra context": "start_date >= CURRENT_DATE - INTERVAL '3 months' AND bonus > 5000",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 46,
      "nl_prompt": "Calculate the average monthly revenue generated from clients in the \"Finance\" industry in the current financial year, considering both invoiced and pending payments.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT AVG(total_amount) AS avg_monthly_revenue FROM invoice WHERE EXTRACT(YEAR FROM invoice_date) = EXTRACT(YEAR FROM CURRENT_DATE) AND status IN ('Invoiced', 'Pending');"
        ],
        "mysql": [
          "SELECT AVG(total_amount) AS avg_monthly_revenue FROM invoice WHERE YEAR(invoice_date) = YEAR(CURDATE()) AND status IN ('Invoiced', 'Pending');"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 47,
      "nl_prompt": "List all employees who have participated in at least one training session conducted by an external trainer in the last year, along with the total number of sessions they attended.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, COUNT(et.training_id) AS total_training_sessions FROM employee e JOIN employee_training et ON e.employee_id = et.employee_id JOIN training t ON et.training_id = t.training_id WHERE t.trainer LIKE '%David%' GROUP BY e.employee_id, e.first_name;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, COUNT(et.training_id) AS total_training_sessions FROM employee e JOIN employee_training et ON e.employee_id = et.employee_id JOIN training t ON et.training_id = t.training_id WHERE et.start_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY e.employee_id, e.first_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Extra context": "External trainer = \"David\"",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 48,
      "nl_prompt": "Identify the employees who have taken more than two sick leaves in the last six months, along with the total duration of their sick leaves.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, SUM(duration) AS total_sick_leave_duration FROM employee e JOIN leave_request l ON e.employee_id = l.employee_id WHERE l.leave_type = 'Sick Leave' AND l.start_date >= CURRENT_DATE - INTERVAL '6 months' GROUP BY e.employee_id, e.first_name HAVING SUM(duration) > 2;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, SUM(duration) AS total_sick_leave_duration FROM employee e JOIN leave_request l ON e.employee_id = l.employee_id WHERE l.leave_type = 'Sick Leave' AND l.start_date >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH) GROUP BY e.employee_id, e.first_name HAVING SUM(duration) > 2;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "DATE",
        "HAVING"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Extra context": "leave_type= 'Sick Leave'"
      }
    },
    {
      "id": 49,
      "nl_prompt": "Determine the total expenses incurred by the company on employee benefits in the last financial year, broken down by each benefit category.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT allowance, SUM(amount) AS total_expenses FROM employee_allowances ea JOIN allowances a ON ea.allowance_id = a.allowance_id WHERE EXTRACT(YEAR FROM ea.effective_date) = EXTRACT(YEAR FROM CURRENT_DATE) - 1 GROUP BY allowance;"
        ],
        "mysql": [
          "SELECT allowance, SUM(amount) AS total_expenses FROM employee_allowances ea JOIN allowances a ON ea.allowance_id = a.allowance_id WHERE YEAR(ea.effective_date) = YEAR(CURDATE()) - 1 GROUP BY allowance;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 50,
      "nl_prompt": "Find the department with the highest average number of hours worked per employee in the six last quarters.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT MIN(d.department_name), AVG(t.working_hours) AS avg_hours_worked_per_employee FROM department d JOIN employee e ON d.department_id = e.department_id JOIN timesheet_employee te ON e.employee_id = te.employee_id JOIN timesheet t ON te.timesheet_id = t.timesheet_id WHERE t.date >= CURRENT_DATE - INTERVAL '18 months' GROUP BY d.department_id ORDER BY avg_hours_worked_per_employee DESC LIMIT 1;"
        ],
        "mysql": [
          "SELECT min(d.department_name), AVG(t.working_hours) AS avg_hours_worked_per_employee FROM department d JOIN employee e ON d.department_id = e.department_id JOIN timesheet_employee te ON e.employee_id = te.employee_id JOIN timesheet t ON te.timesheet_id = t.timesheet_id WHERE t.date >= DATE_SUB(CURDATE(), INTERVAL 18 MONTH) GROUP BY d.department_id ORDER BY avg_hours_worked_per_employee DESC LIMIT 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "DATE",
        "SORT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 51,
      "nl_prompt": "List all employees who have utilized more than half of their annual leave entitlement by the current month.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          "SELECT e.employee_id, e.first_name,SUM(duration) FROM employee e JOIN leave_request l ON e.employee_id = l.employee_id WHERE YEAR(l.start_date) = YEAR(CURDATE()) AND MONTH(l.start_date) <= MONTH(CURDATE()) GROUP BY e.employee_id, e.first_name HAVING SUM(duration) >3;"
        ]
      },
      "eval_query": {
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "HAVING",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 52,
      "nl_prompt": "Calculate the percentage of employees who have completed the training within the last year.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT (COUNT(DISTINCT e.employee_id) * 100 / (SELECT COUNT(*) FROM public.employee)) AS completion_percentage FROM public.employee e JOIN public.employee_training et ON e.employee_id = et.employee_id JOIN public.training t ON et.training_id = t.training_id WHERE t.title IN ('Sales Techniques Workshop', 'Leadership Development Seminar', 'Time Management Seminar') AND et.start_date >= CURRENT_DATE - INTERVAL '1 year';"
        ],
        "mysql": [
          "SELECT (COUNT(DISTINCT e.employee_id) / (SELECT COUNT(*) FROM employee)) * 100 AS completion_percentage FROM employee e JOIN employee_training et ON e.employee_id = et.employee_id JOIN training t ON et.training_id = t.training_id WHERE t.title IN ('Sales Techniques Workshop', 'Leadership Development Seminar','Time Management Seminar') AND et.start_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR);"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "JOIN",
        "DATE"
      ],
      "other": {
        "Extra context": "start_date >= CURRENT_DATE - INTERVAL '1 year'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 53,
      "nl_prompt": "Identify the employees who have attended training sessions categories within the last six months.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name FROM employee e JOIN employee_training et ON e.employee_id = et.employee_id JOIN training t ON et.training_id = t.training_id WHERE t.title IN (SELECT title FROM training) AND et.start_date >= CURRENT_DATE - INTERVAL '6 months' GROUP BY e.employee_id, e.first_name HAVING COUNT(DISTINCT t.title) = 1;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name FROM employee e JOIN employee_training et ON e.employee_id = et.employee_id JOIN training t ON et.training_id = t.training_id WHERE t.title IN (SELECT TITLE FROM training ) AND et.start_date >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH) GROUP BY e.employee_id, e.first_name HAVING COUNT(DISTINCT t.title) = 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "HAVING"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 54,
      "nl_prompt": "Find the employee who has completed the highest number of performance reviews as a reviewer in the past year, along with the average performance rating given by them.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, AVG(performance_rating) AS avg_performance_rating FROM performance_review WHERE review_date >= CURRENT_DATE - INTERVAL '1 year' GROUP BY employee_id ORDER BY COUNT(review_id) DESC LIMIT 1;"
        ],
        "mysql": [
          "SELECT employee_id, AVG(performance_rating) AS avg_performance_rating FROM performance_review WHERE review_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY employee_id ORDER BY COUNT(review_id) DESC LIMIT 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "DATE",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 55,
      "nl_prompt": "Calculate the average number of days taken for the approval or rejection of leave requests categorized by leave type in the last six months.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT leave_type, AVG(approval_date - start_date) AS avg_approval_duration FROM leave_request WHERE status IN ('Approved', 'Rejected') AND approval_date >= CURRENT_DATE - INTERVAL '6 months' GROUP BY leave_type;"
        ],
        "mysql": [
          "SELECT leave_type, AVG(DATEDIFF(approval_date, start_date)) AS avg_approval_duration FROM leave_request WHERE status IN ('Approved', 'Rejected') AND approval_date >= DATE_SUB(CURDATE(), INTERVAL 6 MONTH) GROUP BY leave_type;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 56,
      "nl_prompt": "List all employees who have been assigned company-owned computers with expired warranties, along with the models of their computers.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, ec.model FROM employee e JOIN employee_computer ec ON e.employee_id = ec.employee_id WHERE ec.warranty_expiry_date < CURRENT_DATE;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, ec.model FROM employee e JOIN employee_computer ec ON e.employee_id = ec.employee_id WHERE ec.warranty_expiry_date < CURDATE();"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 57,
      "nl_prompt": "Identify the department with the highest turnover rate based on the number of employee terminations compared to the total number of employees in the department.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT MIN(d.department_name), COUNT(et.employee_id) / COUNT(e.employee_id) AS turnover_rate FROM department d JOIN employee e ON d.department_id = e.department_id LEFT JOIN employee_termination et ON e.employee_id = et.employee_id GROUP BY d.department_id ORDER BY turnover_rate DESC LIMIT 1;"
        ],
        "mysql": [
          "SELECT MIN(d.department_name), COUNT(et.employee_id) / COUNT(e.employee_id) AS turnover_rate FROM department d JOIN employee e ON d.department_id = e.department_id LEFT JOIN employee_termination et ON e.employee_id = et.employee_id GROUP BY d.department_id ORDER BY turnover_rate DESC LIMIT 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "JOIN",
        "DATE",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 58,
      "nl_prompt": "Find the employee who has completed the highest number of training sessions conducted by external trainers in the past year.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, COUNT(training_id) AS total_training_sessions FROM employee_training WHERE start_date >= CURRENT_DATE - INTERVAL '1 year' GROUP BY employee_id ORDER BY total_training_sessions DESC LIMIT 1;"
        ],
        "mysql": [
          "SELECT employee_id, COUNT(training_id) AS total_training_sessions FROM employee_training WHERE start_date >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY employee_id ORDER BY total_training_sessions DESC LIMIT 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "DATE",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 59,
      "nl_prompt": "Determine the total amount spent on employee business expenses categorized by expense category in the last quarter.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT expense_category, SUM(expense_amount) AS total_expense_amount FROM employee_business_expense WHERE expense_date >= CURRENT_DATE - INTERVAL '3 months' GROUP BY expense_category;"
        ],
        "mysql": [
          "SELECT expense_category, SUM(expense_amount) AS total_expense_amount FROM employee_business_expense WHERE expense_date >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH) GROUP BY expense_category;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 60,
      "nl_prompt": "Calculate the average number of hours worked per week by employees who have been with the company for more than one years.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT AVG(working_hours) AS avg_hours_per_week FROM timesheet_employee te JOIN timesheet t ON te.timesheet_id = t.timesheet_id JOIN employee e ON te.employee_id = e.employee_id WHERE e.hire_date <= CURRENT_DATE - INTERVAL '1 year' GROUP BY te.employee_id;"
        ],
        "mysql": [
          "SELECT AVG(Working_hours) AS avg_hours_per_week FROM timesheet_employee te JOIN timesheet t ON te.timesheet_id = t.timesheet_id JOIN employee e ON te.employee_id = e.employee_id WHERE e.hire_date <= DATE_SUB(CURDATE(), INTERVAL 1 YEAR) GROUP BY te.employee_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "JOIN",
        "DATE",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 61,
      "nl_prompt": "Identify the top three employees who have received the highest total allowances in the current year, considering both fixed and variable allowances.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, SUM(ea.amount) AS total_allowances FROM employee e JOIN employee_allowances ea ON e.employee_id = ea.employee_id WHERE EXTRACT(YEAR FROM ea.effective_date) = EXTRACT(YEAR FROM CURRENT_DATE) - 1 GROUP BY e.employee_id, e.first_name ORDER BY total_allowances DESC LIMIT 3;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, SUM(ea.amount) AS total_allowances FROM employee e JOIN employee_allowances ea ON e.employee_id = ea.employee_id WHERE YEAR(ea.effective_date) = YEAR(CURDATE())-1 GROUP BY e.employee_id, e.first_name ORDER BY total_allowances DESC LIMIT 3;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "DATE",
        "SORT",
        "LIMIT",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 62,
      "nl_prompt": "Find the average work hours and overtime hours recorded by employees in the \"Finance\" department in the last month.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT AVG(Working_hours) AS avg_work_hours, AVG(Overtime) AS avg_overtime_hours, min(d.department_name) FROM timesheet_employee te JOIN timesheet t ON te.timesheet_id = t.timesheet_id JOIN employee e ON te.employee_id = e.employee_id JOIN department d ON e.department_id = d.department_id WHERE d.department_name = 'Finance';"
        ],
        "mysql": [
          "SELECT AVG(Working_hours) AS avg_work_hours, AVG(Overtime) AS avg_overtime_hours, min(d.department_name) FROM timesheet_employee te JOIN timesheet t ON te.timesheet_id = t.timesheet_id JOIN employee e ON te.employee_id = e.employee_id JOIN department d ON e.department_id = d.department_id WHERE d.department_name = 'Finance';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Extra context": "department_name = 'Finance'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 63,
      "nl_prompt": "List the holidays observed by the company in the last year, along with the occasions and geographic locations where they were celebrated.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT Date, Occasion, Geographic_location FROM holiday WHERE EXTRACT(YEAR FROM Date) = EXTRACT(YEAR FROM CURRENT_DATE) - 1;"
        ],
        "mysql": [
          "SELECT Date, Occasion, Geographic_location FROM holiday WHERE YEAR(Date) = YEAR(CURDATE()) - 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 64,
      "nl_prompt": "Determine the percentage of employees who have completed mandatory training sessions out of the total number of employees in the company.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT (COUNT(DISTINCT employee_id) * 100 / (SELECT COUNT(*) FROM public.employee)) AS completion_percentage FROM public.employee_training WHERE training_id IN (SELECT training_id FROM public.training WHERE attendance_required = true);"
        ],
        "mysql": [
          "SELECT (COUNT(DISTINCT employee_id) / (SELECT COUNT(*) FROM employee)) * 100 AS completion_percentage FROM employee_training WHERE training_id IN (SELECT training_id FROM training WHERE attendance_required = 1)"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 65,
      "nl_prompt": "Retrieve the names and contact information of employees who have incurred business expenses exceeding $400 in the last quarter.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.first_name, e.email, e.phone_number FROM employee e JOIN employee_business_expense b ON e.employee_id = b.employee_id WHERE b.expense_amount > 400 AND b.expense_date >= CURRENT_DATE - INTERVAL '3 MONTH';"
        ],
        "mysql": [
          "SELECT e.first_name, e.email, e.phone_number FROM employee e JOIN employee_business_expense b ON e.employee_id = b.employee_id WHERE b.expense_amount > 400 AND b.expense_date >= DATE_SUB(CURDATE(), INTERVAL 3 MONTH);"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JOIN",
        "DATE"
      ],
      "other": {
        "Extra context": "expense_amount > 400 AND b.expense_date >= CURRENT_DATE - INTERVAL '3 MONTH'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 66,
      "nl_prompt": "List all employees who have traveled to the \"New York\" location for business purposes in the last 12 months, along with their travel expenses.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, t.travel_expenses FROM employee e JOIN employee_travel t ON e.employee_id = t.employee_id WHERE t.travel_destination LIKE '%New York%' AND t.travel_start_date >= CURRENT_DATE - INTERVAL '12 MONTH';"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, t.travel_expenses FROM employee e JOIN employee_travel t ON e.employee_id = t.employee_id WHERE t.travel_destination like '%New York%' AND t.travel_start_date >= DATE_SUB(CURDATE(), INTERVAL 12 MONTH);"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JOIN",
        "DATE"
      ],
      "other": {
        "Extra context": "travel_destination LIKE '%New York%'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 67,
      "nl_prompt": "Find the average duration of leaves taken by employees in the last financial year.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT AVG(duration) AS average_leave_duration FROM leave_request WHERE EXTRACT(YEAR FROM start_date) = EXTRACT(YEAR FROM CURRENT_DATE) - 1;"
        ],
        "mysql": [
          "SELECT AVG(duration) AS average_leave_duration FROM leave_request WHERE YEAR(start_date) = YEAR(CURDATE()) - 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 68,
      "nl_prompt": "List all employees who have received a certification from \"Microsoft\" and whose certification expiration date is within the next three months.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT * FROM employee_certification WHERE issuing_organization = 'Microsoft' AND expiration_date >= CURRENT_DATE - INTERVAL '90 days';"
        ],
        "mysql": [
          "SELECT * FROM employee_certification WHERE issuing_organization = 'Microsoft' AND expiration_date >=DATE_SUB(CURRENT_DATE(), INTERVAL 90 DAY);"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 69,
      "nl_prompt": "Find the employee with the lowest total compensation in the current year, considering only employees in the \"Finance\" department.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, s.total_compensation, e.department_id FROM employee e JOIN salary s ON e.employee_id = s.employee_id WHERE s.start_date >= '2023-01-01' AND e.department_id = (SELECT department_id FROM department WHERE department_name = 'Finance') ORDER BY s.total_compensation LIMIT 1;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, s.total_compensation,department_id FROM employee e JOIN salary s ON e.employee_id = s.employee_id WHERE s.start_date >= '2023-01-01' -- current financial year AND e.department_id = (SELECT department_id FROM department WHERE department_name = 'Finance') ORDER BY s.total_compensation LIMIT 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "SORT",
        "LIMIT"
      ],
      "other": {
        "Extra context": "department_name = 'Finance'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 70,
      "nl_prompt": "List the top 10 employees with the highest bonus amount in the last quarter.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, s.bonus FROM employee e JOIN salary s ON e.employee_id = s.employee_id WHERE s.start_date >= '2024-01-01' AND s.start_date < '2024-04-01' ORDER BY s.bonus DESC LIMIT 10;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, s.bonus FROM employee e JOIN salary s ON e.employee_id = s.employee_id WHERE s.start_date >= '2024-01-01' AND s.start_date < '2024-04-01' ORDER BY s.bonus DESC LIMIT 10;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "SORT",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 71,
      "nl_prompt": "Determine the percentage increase in average salary from the previous financial year to the current financial year for employees in the \"Finance\" department.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT ((current_year_avg_salary - prev_year_avg_salary) / prev_year_avg_salary) * 100 AS percentage_increase FROM (SELECT AVG(salary) AS current_year_avg_salary FROM salary WHERE start_date >= '2024-01-01' AND start_date < '2025-01-01' AND employee_id IN (SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Finance'))) AS current_year, (SELECT AVG(salary) AS prev_year_avg_salary FROM salary WHERE start_date >= '2023-01-01' AND start_date < '2024-01-01' AND employee_id IN (SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Finance'))) AS prev_year;"
        ],
        "mysql": [
          "SELECT ((current_year_avg_salary - prev_year_avg_salary) / prev_year_avg_salary) * 100 AS percentage_increase FROM (SELECT AVG(salary) AS current_year_avg_salary FROM salary WHERE start_date >= '2024-01-01' AND start_date < '2025-01-01' -- current financial year AND employee_id IN (SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Finance'))) AS current_year, (SELECT AVG(salary) AS prev_year_avg_salary FROM salary WHERE start_date >= '2023-01-01' AND start_date < '2024-01-01' -- previous financial year AND employee_id IN (SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Finance'))) AS prev_year;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Extra context": "department_name = 'Finance'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 72,
      "nl_prompt": "Calculate the average salary of employees in each department, considering only full-time employees.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT d.department_name, AVG(s.salary) AS average_salary FROM employee e JOIN department d ON e.department_id = d.department_id JOIN salary s ON e.employee_id = s.employee_id WHERE e.contract_type = 'Full-time' GROUP BY d.department_name;"
        ],
        "mysql": [
          "SELECT d.department_name, AVG(s.salary) AS average_salary FROM employee e JOIN department d ON e.department_id = d.department_id JOIN salary s ON e.employee_id = s.employee_id WHERE e.contract_type = 'Full-time' GROUP BY d.department_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE"
      ],
      "other": {
        "Extra context": "contract_type = 'Full-time'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 73,
      "nl_prompt": "List all employees whose total compensation (salary + bonus - taxes - deductions) exceeds $10000 in the last financial year",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name FROM employee e JOIN salary s ON e.employee_id = s.employee_id WHERE s.start_date >= '2023-01-01' AND s.total_compensation > 10000;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name FROM employee e JOIN salary s ON e.employee_id = s.employee_id WHERE s.start_date >= '2023-01-01' -- assuming the start of the current financial year AND s.total_compensation > 10000;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Extra context": "s.start_date >= '2023-01-01' AND s.total_compensation > 10000",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 74,
      "nl_prompt": "Retrieve all employees who have a bank account in a Anothertown City from their address.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          "SELECT * FROM employee WHERE JSON_EXTRACT(address, '$.city') = 'Anothertown';"
        ]
      },
      "eval_query": {
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JSON_EXTRACT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 75,
      "nl_prompt": "Find employees who have received a certification that matches a 'AWS' & 'AMAZON' keyword in its name or issuing organization.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT * FROM employee_certification WHERE certification_name LIKE '%AWS%' OR issuing_organization LIKE '%AMAZON%';"
        ],
        "mysql": [
          "SELECT * FROM employee_certification WHERE certification_name LIKE '%AWS%' OR issuing_organization LIKE '%AMAZON%';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "LIKE"
      ],
      "other": {
        "Extra context": "certification_name LIKE '%AWS%' OR issuing_organization LIKE '%AMAZON%'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 76,
      "nl_prompt": "Identify employees who have requested a leave due to personal reasons and provide their emergency contact details.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.*, lr.reason, e.emergency_contact_name, e.emergency_contact_number, lr.leave_type FROM employee e INNER JOIN leave_request lr ON e.employee_id = lr.employee_id WHERE lr.leave_type LIKE '%Personal%';"
        ],
        "mysql": [
          "SELECT e.*, lr.reason, e.emergency_contact_name, e.emergency_contact_number,leave_type FROM employee e INNER JOIN leave_request lr ON e.employee_id = lr.employee_id WHERE lr.leave_type like '%Personal%';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Extra context": "leave_type= 'Personal'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 77,
      "nl_prompt": "Retrieve employees who have worked overtime for more than 1 hours in a single shift.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT * FROM attendance WHERE overtime_hours >= 1;"
        ],
        "mysql": [
          "SELECT * FROM attendance WHERE overtime_hours >= 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT"
      ],
      "other": {
        "Extra context": "overtime_hours= 2",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 78,
      "nl_prompt": "Find employees who have taken sick leave are twice or more in the last quarter and list their total sick leave duration.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, SUM(lr.end_date - lr.start_date) AS total_sick_leave_days FROM employee e JOIN leave_request lr ON e.employee_id = lr.employee_id WHERE lr.leave_type = 'Sick Leave' AND lr.start_date >= CURRENT_DATE - INTERVAL '3 MONTH' GROUP BY e.employee_id, e.first_name, e.last_name HAVING SUM(lr.end_date - lr.start_date) >= 2;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, SUM(DATEDIFF(lr.end_date, lr.start_date)) AS total_sick_leave_days FROM employee e JOIN leave_request lr ON e.employee_id = lr.employee_id WHERE lr.leave_type = 'Sick Leave' AND lr.start_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) GROUP BY e.employee_id, e.first_name, e.last_name HAVING SUM(DATEDIFF(lr.end_date, lr.start_date)) >= 2;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "HAVING",
        "JOIN"
      ],
      "other": {
        "Extra context": "leave_type= 'Sick Leave'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 79,
      "nl_prompt": "Identify employees who have not completed mandatory training sessions in the last six months, along with the total number of sessions missed",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, COUNT(t.training_id) AS total_sessions_missed FROM employee e LEFT JOIN employee_training te ON e.employee_id = te.employee_id LEFT JOIN training t ON te.training_id = t.training_id WHERE t.date >= CURRENT_DATE - INTERVAL '6 MONTH' AND t.attendance_required = true AND t.status = 'Active' GROUP BY e.employee_id, e.first_name, e.last_name;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, COUNT(t.training_id) AS total_sessions_missed FROM employee e LEFT JOIN employee_training te ON e.employee_id = te.employee_id LEFT JOIN training t ON te.training_id = t.training_id WHERE t.date >= DATE_SUB(CURRENT_DATE(), INTERVAL 6 MONTH) AND t.attendance_required = 1 AND t.status = 'Active' GROUP BY e.employee_id, e.first_name, e.last_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "LEFT_JOIN",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Extra context": "t.attendance_required = 1, t.status = 'Active'"
      }
    },
    {
      "id": 80,
      "nl_prompt": "Determine the top three employees with the highest total business expenses in the last quarter, considering expenses across all categories.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, SUM(ebe.expense_amount) AS total_business_expenses FROM employee e JOIN employee_business_expense ebe ON e.employee_id = ebe.employee_id WHERE ebe.expense_date BETWEEN CURRENT_DATE - INTERVAL '3 MONTH' AND CURRENT_DATE GROUP BY e.employee_id, e.first_name, e.last_name ORDER BY total_business_expenses DESC LIMIT 3;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, SUM(ebe.expense_amount) AS total_business_expenses FROM employee e JOIN employee_business_expense ebe ON e.employee_id = ebe.employee_id WHERE ebe.expense_date BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE() GROUP BY e.employee_id, e.first_name, e.last_name ORDER BY total_business_expenses DESC LIMIT 3;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "DATE",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 81,
      "nl_prompt": "Retrieve the total number of employees working in each department of the company.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT d.department_name, COUNT(e.employee_id) AS total_employees FROM department d LEFT JOIN employee e ON d.department_id = e.department_id GROUP BY d.department_name;"
        ],
        "mysql": [
          "SELECT d.department_name, COUNT(e.employee_id) AS total_employees FROM department d LEFT JOIN employee e ON d.department_id = e.department_id GROUP BY d.department_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 82,
      "nl_prompt": "List all clients of the company operating in the healthcare industry.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT company_name, clients FROM company WHERE industry = 'Healthcare';"
        ],
        "mysql": [
          "SELECT company_name, clients FROM company WHERE industry = 'Healthcare';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT"
      ],
      "other": {
        "Extra context": "industry = 'Healthcare'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 83,
      "nl_prompt": "Calculate the average budget allocated to each department over the past three years.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT department_name, AVG(budget) AS avg_budget FROM department WHERE start_date >= CURRENT_DATE - INTERVAL '3 YEAR' GROUP BY department_name;"
        ],
        "mysql": [
          "SELECT department_name, AVG(budget) AS avg_budget FROM department WHERE start_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 3 YEAR) GROUP BY department_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 84,
      "nl_prompt": "Identify the companys top three competitors based on the number of shared clients",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT competitors, COUNT(*) AS shared_clients FROM company GROUP BY competitors ORDER BY shared_clients DESC LIMIT 3;"
        ],
        "mysql": [
          "SELECT competitors, COUNT(*) AS shared_clients FROM company GROUP BY competitors ORDER BY shared_clients DESC LIMIT 3;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 85,
      "nl_prompt": "Find the number of vacancies available for each job title in the company.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT job_title, COUNT(*) AS vacancies FROM job GROUP BY job_title;"
        ],
        "mysql": [
          "SELECT job_title, COUNT(*) AS vacancies FROM job GROUP BY job_title;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 86,
      "nl_prompt": "Retrieve the contact information of employees who joined the company in the last six months.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT first_name, last_name, email, phone_number FROM employee WHERE hire_date >= CURRENT_DATE - INTERVAL '6 MONTH';"
        ],
        "mysql": [
          "SELECT first_name, last_name, email, phone_number FROM employee WHERE hire_date >= DATE_SUB(CURRENT_DATE(), INTERVAL 6 MONTH);"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 87,
      "nl_prompt": "Retrieve the total number of employees managed by each manager.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT MIN(m.manager_id), MIN(CONCAT(e.first_name, ' ', e.last_name)) AS manager_name, COUNT(*) AS total_employees_managed FROM manager m JOIN employee e ON m.manager_id = e.manager_id GROUP BY m.manager_id;"
        ],
        "mysql": [
          "SELECT min(m.manager_id), min(CONCAT(e.first_name, ' ', e.last_name)) AS manager_name, COUNT(*) AS total_employees_managed FROM manager m JOIN employee e ON m.manager_id = e.manager_id GROUP BY m.manager_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 88,
      "nl_prompt": "List all managers who have been assigned to departments with budgets exceeding $100,000.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.first_name, e.last_name, d.department_name FROM manager m JOIN employee e ON m.manager_id = e.manager_id JOIN department d ON m.manager_id = d.manager_id WHERE d.budget > 100000;"
        ],
        "mysql": [
          "SELECT e.first_name, e.last_name, d.department_name FROM manager m JOIN employee e ON m.manager_id = e.manager_id JOIN department d ON m.manager_id = d.manager_id WHERE d.budget > 100000;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Extra context": "budget = 100000",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 89,
      "nl_prompt": "Identify employee who have received performance ratings above 3 in their last review.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.first_name, e.last_name, pr.performance_rating FROM employee e JOIN performance_review pr ON e.employee_id = pr.employee_id WHERE pr.performance_rating > 3;"
        ],
        "mysql": [
          "SELECT e.first_name, e.last_name, pr.performance_rating FROM employee e JOIN performance_review pr ON e.employee_id = pr.employee_id WHERE pr.performance_rating > 3;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Extra context": "performance_rating =3"
      }
    },
    {
      "id": 90,
      "nl_prompt": "Determine the total amount spent on salaries for each pay frequency (e.g., monthly, bi-weekly).",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT pay_frequency, SUM(salary) AS total_salary_expense FROM salary GROUP BY pay_frequency;"
        ],
        "mysql": [
          "SELECT pay_frequency, SUM(salary) AS total_salary_expense FROM salary GROUP BY pay_frequency;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 91,
      "nl_prompt": "Identify employees who have had a decrease in salary in their most recent salary update.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.first_name, e.last_name, s.salary FROM employee e JOIN salary s ON e.employee_id = s.employee_id WHERE s.salary <= (SELECT MAX(salary) FROM salary WHERE employee_id = e.employee_id);"
        ],
        "mysql": [
          "SELECT e.first_name, e.last_name, s.salary FROM employee e JOIN salary s ON e.employee_id = s.employee_id WHERE salary <= (SELECT MAX(salary) FROM salary WHERE employee_id = e.employee_id);"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 93,
      "nl_prompt": "Determine the number of employees enrolled in each benefit program.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT b.benefit_name, COUNT(eb.employee_id) AS total_enrolled FROM benefit b LEFT JOIN employee_x_benefit eb ON b.benefit_id = eb.benefit_id GROUP BY b.benefit_name;"
        ],
        "mysql": [
          "SELECT b.benefit_name, COUNT(eb.employee_id) AS total_enrolled FROM benefit b LEFT JOIN employee_x_benefit eb ON b.benefit_id = eb.benefit_id GROUP BY b.benefit_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "LEFT_JOIN",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 94,
      "nl_prompt": "Calculate the total duration of training sessions attended by each employee.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, MAX(e.first_name) AS first_name, MAX(e.last_name) AS last_name, SUM((et.end_date - et.start_date) / 60) AS total_training_duration_minutes FROM employee e JOIN employee_training et ON e.employee_id = et.employee_id GROUP BY e.employee_id;"
        ],
        "mysql": [
          "SELECT e.employee_id, MAX(e.first_name) AS first_name, MAX(e.last_name) AS last_name, SUM(TIMESTAMPDIFF(MINUTE, et.start_date, et.end_date)) AS total_training_duration_minutes FROM employee e JOIN employee_training et ON e.employee_id = et.employee_id GROUP BY e.employee_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 95,
      "nl_prompt": "Retrieve the list of employees who have been enrolled in benefits with their start and end dates",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.first_name, e.last_name, b.benefit_name, eb.start_date, eb.end_date FROM employee e JOIN employee_x_benefit eb ON e.employee_id = eb.employee_id JOIN benefit b ON eb.benefit_id = b.benefit_id;"
        ],
        "mysql": [
          "SELECT e.first_name, e.last_name, b.benefit_name, eb.start_date, eb.end_date FROM employee e JOIN employee_x_benefit eb ON e.employee_id = eb.employee_id JOIN benefit b ON eb.benefit_id = b.benefit_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 96,
      "nl_prompt": "Determine the total number of benefits each employee is enrolled in.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, MAX(e.first_name) AS first_name, MAX(e.last_name) AS last_name, COUNT(eb.benefit_id) AS total_benefits_enrolled FROM employee e LEFT JOIN employee_x_benefit eb ON e.employee_id = eb.employee_id GROUP BY e.employee_id;"
        ],
        "mysql": [
          "SELECT e.employee_id, MAX(e.first_name) AS first_name, MAX(e.last_name) AS last_name, COUNT(eb.benefit_id) AS total_benefits_enrolled FROM employee e LEFT JOIN employee_x_benefit eb ON e.employee_id = eb.employee_id GROUP BY e.employee_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "LEFT_JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 97,
      "nl_prompt": "List all employees who have checked in from a location outside their designated work location.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.first_name, e.last_name, a.date, a.check_in_location FROM employee e JOIN attendance a ON e.employee_id = a.employee_id WHERE a.check_in_location IN (SELECT check_in_location FROM attendance);"
        ],
        "mysql": [
          "SELECT e.first_name, e.last_name, a.date, a.check_in_location FROM employee e JOIN attendance a ON e.employee_id = a.employee_id WHERE a.check_in_location IN (SELECT check_in_location FROM attendance );"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 98,
      "nl_prompt": "Calculate the total duration of approved leaves for each employee.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.first_name, e.last_name, SUM(lr.duration) AS total_approved_leave_duration FROM employee e JOIN leave_request lr ON e.employee_id = lr.employee_id WHERE lr.status = 'Approved' GROUP BY e.employee_id, e.first_name, e.last_name;"
        ],
        "mysql": [
          "SELECT e.first_name, e.last_name, SUM(lr.duration) AS total_approved_leave_duration FROM employee e JOIN leave_request lr ON e.employee_id = lr.employee_id WHERE lr.status = 'Approved' GROUP BY e.employee_id, e.first_name, e.last_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 99,
      "nl_prompt": "List all employees who have requested sick leave due to Illness symptoms.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.first_name, e.last_name, lr.start_date, lr.end_date, lr.reason FROM employee e JOIN leave_request lr ON e.employee_id = lr.employee_id WHERE lr.leave_type = 'Sick Leave' AND lr.reason LIKE '%Illness';"
        ],
        "mysql": [
          "SELECT e.first_name, e.last_name, lr.start_date, lr.end_date, lr.reason FROM employee e JOIN leave_request lr ON e.employee_id = lr.employee_id WHERE lr.leave_type = 'Sick Leave' AND lr.reason LIKE '%Illness';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "LIKE"
      ],
      "other": {
        "Extra context": "leave_type = 'Sick Leave', reason LIKE '%Illness'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 100,
      "nl_prompt": "List all employees who have attended training sessions on weekends.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.first_name, e.last_name, t.title, t.date FROM employee e JOIN employee_training et ON e.employee_id = et.employee_id JOIN training t ON et.training_id = t.training_id WHERE EXTRACT(ISODOW FROM t.date) IN (6, 7);"
        ],
        "mysql": [
          "SELECT e.first_name, e.last_name, t.title, t.date FROM employee e JOIN employee_training et ON e.employee_id = et.employee_id JOIN training t ON et.training_id = t.training_id WHERE DAYOFWEEK(t.date) IN (1, 7);"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 101,
      "nl_prompt": "Retrieve the list of computers assigned to employees along with their warranty expiry dates.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.first_name, e.last_name, ec.computer_name, ec.serial_number, ec.model, ec.warranty_expiry_date FROM employee e JOIN employee_computer ec ON e.employee_id = ec.employee_id;"
        ],
        "mysql": [
          "SELECT e.first_name, e.last_name, ec.computer_name, ec.serial_number, ec.model, ec.warranty_expiry_date FROM employee e JOIN employee_computer ec ON e.employee_id = ec.employee_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 102,
      "nl_prompt": "Average performance rating of each employee in the last quarter, along with their attendance record and completion status of mandatory training sessions",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, AVG(pr.performance_rating) AS avg_performance_rating, COUNT(DISTINCT a.date) AS days_worked, COUNT(DISTINCT et.training_id) AS training_completed FROM employee e LEFT JOIN performance_review pr ON e.employee_id = pr.employee_id LEFT JOIN attendance a ON e.employee_id = a.employee_id AND a.date BETWEEN CURRENT_DATE - INTERVAL '3 MONTH' AND CURRENT_DATE LEFT JOIN employee_training et ON e.employee_id = et.employee_id AND et.start_date BETWEEN CURRENT_DATE - INTERVAL '3 MONTH' AND CURRENT_DATE GROUP BY e.employee_id, e.first_name, e.last_name;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, AVG(pr.performance_rating) AS avg_performance_rating, COUNT(DISTINCT a.date) AS days_worked, COUNT(DISTINCT et.training_id) AS training_completed FROM employee e LEFT JOIN performance_review pr ON e.employee_id = pr.employee_id LEFT JOIN attendance a ON e.employee_id = a.employee_id AND a.date BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE() LEFT JOIN employee_training et ON e.employee_id = et.employee_id AND et.start_date BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE() GROUP BY e.employee_id, e.first_name, e.last_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "LEFT_JOIN",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 103,
      "nl_prompt": "List of employees who have completed at least one certification within the past year, sorted by their job title and department",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, e.email, j.job_title, d.department_name, ec.certification_name, ec.issue_date, ec.expiration_date FROM employee e JOIN job_history jh ON e.employee_id = jh.employee_id JOIN job j ON jh.job_id = j.job_id JOIN department d ON j.department_id = d.department_id JOIN employee_certification ec ON e.employee_id = ec.employee_id AND ec.issue_date BETWEEN CURRENT_DATE - INTERVAL '4 YEAR' AND CURRENT_DATE JOIN (SELECT job_id, MAX(start_date) AS max_start_date FROM job_history GROUP BY job_id) AS latest_job ON jh.job_id = latest_job.job_id AND jh.start_date = latest_job.max_start_date ORDER BY j.job_title, d.department_name;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, e.email, j.job_title, -- Assuming job_title is a column in the job table d.department_name, ec.certification_name, ec.issue_date, ec.expiration_date FROM employee e JOIN job_history jh ON e.employee_id = jh.employee_id JOIN job j ON jh.job_id = j.job_id JOIN department d ON j.department_id = d.department_id JOIN employee_certification ec ON e.employee_id = ec.employee_id AND ec.issue_date BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 4 YEAR) AND CURRENT_DATE() JOIN (SELECT job_id, MAX(start_date) AS max_start_date FROM job_history GROUP BY job_id) AS latest_job ON jh.job_id = latest_job.job_id AND jh.start_date = latest_job.max_start_date ORDER BY j.job_title, d.department_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "JOIN",
        "DATE",
        "SORT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 104,
      "nl_prompt": "Identify employees with a high number of job changes in the last two years, along with their current job titles and departmental information",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, e.email, j.job_title, d.department_name, COUNT(DISTINCT jh.job_history_id) AS job_changes FROM employee e JOIN job_history jh ON e.employee_id = jh.employee_id AND jh.start_date BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 4 YEAR) AND CURRENT_DATE() JOIN job j ON jh.job_id = j.job_id JOIN department d ON j.department_id = d.department_id GROUP BY e.employee_id, e.first_name, e.last_name, e.email, j.job_title, d.department_name ORDER BY job_changes DESC;"
        ]
      },
      "eval_query": {
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "AGGREGATE",
        "JOIN",
        "SORT",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 105,
      "nl_prompt": "Total salary expenditure for each department in the current financial year, including bonuses, taxes, and deductions",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT d.department_name, SUM(s.salary + s.bonus - s.taxes - s.deductions) AS total_salary_expenditure FROM department d JOIN employee e ON d.department_id = e.department_id JOIN salary s ON e.employee_id = s.employee_id AND s.start_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY d.department_name;"
        ],
        "mysql": [
          "SELECT d.department_name, SUM(s.salary + s.bonus - s.taxes - s.deductions) AS total_salary_expenditure FROM department d JOIN employee e ON d.department_id = e.department_id JOIN salary s ON e.employee_id = s.employee_id AND s.start_date BETWEEN '2023-01-01' AND '2023-12-31' GROUP BY d.department_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "AGGREGATE",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 106,
      "nl_prompt": "Calculate the average training expenses incurred per employee in the last quarter, categorized by department and job title",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT d.department_name, j.job_title, AVG(t.duration) AS avg_training_expenses_per_employee FROM department d JOIN job j ON d.department_id = j.department_id JOIN employee e ON j.job_id = e.job_id JOIN employee_training et ON e.employee_id = et.employee_id AND et.start_date BETWEEN CURRENT_DATE - INTERVAL '3 MONTH' AND CURRENT_DATE JOIN training t ON et.training_id = t.training_id GROUP BY d.department_name, j.job_title;"
        ],
        "mysql": [
          "SELECT d.department_name, j.job_title, AVG(t.duration) AS avg_training_expenses_per_employee FROM department d JOIN job j ON d.department_id = j.department_id JOIN employee e ON j.job_id = e.job_id JOIN employee_training et ON e.employee_id = et.employee_id AND et.start_date BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE() JOIN training t ON et.training_id = t.training_id GROUP BY d.department_name, j.job_title;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "AGGREGATE",
        "JOIN",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 107,
      "nl_prompt": "List all employees eligible for health insurance benefits, including their dependents coverage status and contact information for insurance providers",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, e.email, eb.start_date, eb.end_date, b.benefit_name, b.description AS benefit_description, b.coverage, b.provider AS insurance_provider, e.address ->> '$.dependents' AS dependents FROM employee e JOIN employee_x_benefit eb ON e.employee_id = eb.employee_id JOIN benefit b ON eb.benefit_id = b.benefit_id WHERE b.benefit_name = 'Health Insurance';"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, e.email, eb.start_date, eb.end_date, b.benefit_name, b.description AS benefit_description, b.coverage, b.provider AS insurance_provider, e.address ->> '$.dependents' AS dependents FROM employee e JOIN employee_x_benefit eb ON e.employee_id = eb.employee_id JOIN benefit b ON eb.benefit_id = b.benefit_id WHERE b.benefit_name = 'Health Insurance';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 108,
      "nl_prompt": "Calculate the total cost of travel allowances reimbursed to employees for business trips to locations in the last quarter, categorized by travel destination and purpose",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          "SELECT et.travel_destination, et.travel_purpose, SUM(et.travel_expenses) AS total_travel_allowances FROM employee_travel et WHERE et.travel_start_date BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 3 MONTH) AND CURRENT_DATE() GROUP BY et.travel_destination, et.travel_purpose;"
        ]
      },
      "eval_query": {
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 109,
      "nl_prompt": "Identify employees who have exceeded their allocated budget for business expenses, along with details of the expense categories and reasons for overspending",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT eb.employee_id, e.first_name, e.last_name, eb.expense_category, eb.expense_description, eb.expense_amount, eb.expense_receipt FROM employee_business_expense eb JOIN employee e ON eb.employee_id = e.employee_id WHERE eb.expense_amount > 300 ORDER BY eb.employee_id, eb.expense_amount DESC;"
        ],
        "mysql": [
          "SELECT eb.employee_id, e.first_name, e.last_name, eb.expense_category, eb.expense_description, eb.expense_amount, eb.expense_receipt FROM employee_business_expense eb JOIN employee e ON eb.employee_id = e.employee_id WHERE eb.expense_amount > 300 ORDER BY eb.employee_id, eb.expense_amount DESC;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "JOIN",
        "SORT"
      ],
      "other": {
        "Extra context": "expense_amount > 3000",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 110,
      "nl_prompt": "Calculate the correlation between employee attendance records and their performance ratings over the past year to assess the impact of attendance on job performance",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT AVG(a.work_hours) AS avg_work_hours, AVG(pr.performance_rating) AS avg_performance_rating FROM attendance a JOIN performance_review pr ON a.employee_id = pr.employee_id GROUP BY a.employee_id;"
        ],
        "mysql": [
          "SELECT AVG(a.work_hours) AS avg_work_hours, AVG(pr.performance_rating) AS avg_performance_rating FROM attendance a JOIN performance_review pr ON a.employee_id = pr.employee_id GROUP BY a.employee_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "AGGREGATE",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 111,
      "nl_prompt": "List employees who have requested leave due to burnout or work-related stress in the last six months, along with their leave duration and reasons cited in their leave requests",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, lr.leave_type, lr.start_date, lr.end_date, lr.duration, lr.reason, lr.comments FROM employee e JOIN leave_request lr ON e.employee_id = lr.employee_id WHERE lr.start_date BETWEEN CURRENT_DATE - INTERVAL '6 MONTH' AND CURRENT_DATE AND (lr.reason LIKE '%Personal%' OR lr.reason LIKE '%stress%');"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, lr.leave_type, lr.start_date, lr.end_date, lr.duration, lr.reason, lr.comments FROM employee e JOIN leave_request lr ON e.employee_id = lr.employee_id WHERE lr.start_date BETWEEN DATE_SUB(CURRENT_DATE(), INTERVAL 6 MONTH) AND CURRENT_DATE() AND (lr.reason LIKE '%vacation%' OR lr.reason LIKE '%stress%');"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "JOIN",
        "DATE",
        "LIKE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 112,
      "nl_prompt": "Analyze the geographic distribution of company clients and partners to identify regions with potential for business expansion or partnership opportunities",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT c.location, COUNT(DISTINCT c.clients) AS total_clients, COUNT(DISTINCT c.partners) AS total_partners FROM company c GROUP BY c.location;"
        ],
        "mysql": [
          "SELECT c.location, COUNT(DISTINCT c.clients) AS total_clients, COUNT(DISTINCT c.partners) AS total_partners FROM company c GROUP BY c.location;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 113,
      "nl_prompt": "Determine the average tenure of employees in each department and job role to assess employee retention rates and identify areas for talent development and succession planning",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT d.department_name, j.job_title, AVG(EXTRACT(DAY FROM NOW() - e.hire_date)) AS avg_tenure_in_days FROM department d JOIN employee e ON d.department_id = e.department_id JOIN job j ON e.job_id = j.job_id GROUP BY d.department_name, j.job_title;"
        ],
        "mysql": [
          "SELECT d.department_name, j.job_title, AVG(DATEDIFF(NOW(), e.hire_date)) AS avg_tenure_in_days FROM department d JOIN employee e ON d.department_id = e.department_id JOIN job j ON e.job_id = j.job_id GROUP BY d.department_name, j.job_title;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 114,
      "nl_prompt": "Determine the number of employees assigned each computer model",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT model, COUNT(employee_id) AS num_employees_assigned FROM employee_computer GROUP BY model;"
        ],
        "mysql": [
          "SELECT model, COUNT(employee_id) AS num_employees_assigned FROM employee_computer GROUP BY model;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 115,
      "nl_prompt": "How can i update the email address of the employee with ID 3536251 to \"newemail@example.com\"?",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee SET email = 'newemail@example.com' WHERE employee_id = 3536251;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_email_count FROM employee WHERE email = 'newemail@example.com';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_email_count FROM employee WHERE email = 'newemail@example.com';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee SET email = 'john.doe@example.com' WHERE employee_id = 3536251;"
        ],
        "mysql": [
          "UPDATE employee SET email = 'john.doe@example.com' WHERE employee_id = 3536251;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee SET email = 'john.doe@example.com' WHERE employee_id = 3536251;"
        ],
        "mysql": [
          "UPDATE employee SET email = 'john.doe@example.com' WHERE employee_id = 3536251;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "employee_id = 3536251",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 116,
      "nl_prompt": "How can i update the budget of the Human Resources department to $100000.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE department SET budget = 100000 WHERE department_name = 'Human Resources';"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_department_count FROM department WHERE department_name = 'Human Resources' AND budget = 100000;"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_department_count FROM department WHERE department_name = 'Human Resources' AND budget = 1000000;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE department SET budget = 100000 WHERE department_name = 'Human Resources';"
        ],
        "mysql": [
          "UPDATE department SET budget = 100000 WHERE department_name = 'Human Resources';"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE department SET budget = 100000 WHERE department_name = 'Human Resources';"
        ],
        "mysql": [
          "UPDATE department SET budget = 100000 WHERE department_name = 'Human Resources';"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "department_name= 'Human Resources'",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 117,
      "nl_prompt": "How can i Update the job description of the position with ID 5 to include new responsibilities.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE job SET job_description = CONCAT(job_description, ' New responsibilities include...') WHERE job_id = 5;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_jobs_count FROM job WHERE job_id = 5 AND job_description LIKE '%New responsibilities include...%';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_jobs_count FROM job WHERE job_id = 5 AND job_description LIKE '%New responsibilities include...%';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE job SET job_description = 'Responsible for handling various HR functions.' WHERE job_id = 5;"
        ],
        "mysql": [
          "UPDATE job SET job_description = 'Responsible for handling various HR functions.' WHERE job_id = 5;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE job SET job_description = 'Responsible for handling various HR functions.' WHERE job_id = 5;"
        ],
        "mysql": [
          "UPDATE job SET job_description = 'Responsible for handling various HR functions.' WHERE job_id = 5;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "job_id =5",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 118,
      "nl_prompt": "How can i Update the manager for the Sales department to employee ID 205.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "mysql": [
          "SELECT COUNT(*) AS updated_department_count FROM department WHERE department_name = 'Sales' AND manager_id = 205;"
        ]
      },
      "setup_sql": {
        "mysql": [
          "UPDATE department SET manager_id = 4 WHERE department_name = 'Sales';"
        ]
      },
      "cleanup_sql": {
        "mysql": [
          "UPDATE department SET manager_id = 4 WHERE department_name = 'Sales';"
        ]
      },
      "tags": [
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "department_name= 'Sales'",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 119,
      "nl_prompt": "Mark the attendance of employee ID 3536269 on 2024-02-28 with check-out time as 18:00:00 and notes as 'Completed tasks'.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE attendance SET check_out_time = '18:00:00', notes = 'Completed tasks' WHERE employee_id = 3536269 AND date = '2024-02-28';"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_attendance_count FROM attendance WHERE employee_id = 3536269 AND date = '2024-02-28' AND check_out_time = '18:00:00' AND notes = 'Completed tasks';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_attendance_count FROM attendance WHERE employee_id = 3536269 AND date = '2022-01-01' AND check_out_time = '18:00:00' AND notes = 'Completed tasks';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE attendance SET check_out_time = '17:15:00', notes = 'Regular work hours' WHERE employee_id = 3536269 AND date = '2022-01-01';"
        ],
        "mysql": [
          "UPDATE attendance SET check_out_time = '17:15:00', notes = 'Regular work hours' WHERE employee_id = 3536269 AND date = '2022-01-01';"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE attendance SET check_out_time = '17:15:00', notes = 'Regular work hours' WHERE employee_id = 3536269 AND date = '2022-01-01';"
        ],
        "mysql": [
          "UPDATE attendance SET check_out_time = '17:15:00', notes = 'Regular work hours' WHERE employee_id = 3536269 AND date = '2022-01-01';"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "employee_id = 3536269 date = '2024-02-28'",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 120,
      "nl_prompt": "How can i update the leave status of leave ID 5 to 'Approved'.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE leave_request SET status = 'Approved' WHERE leave_id = 5;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_leave_request_count FROM leave_request WHERE leave_id = 5 AND status = 'Approved';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_leave_request_count FROM leave_request WHERE leave_id = 5 AND status = 'Approved';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE leave_request SET status = 'Approved' WHERE leave_id = 5;"
        ],
        "mysql": [
          "UPDATE leave_request SET status = 'Approved' WHERE leave_id = 5;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE leave_request SET status = 'Approved' WHERE leave_id = 5;"
        ],
        "mysql": [
          "UPDATE leave_request SET status = 'Approved' WHERE leave_id = 5;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "leave_id = 5",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 121,
      "nl_prompt": "Extend the joining date of the training session with ID 107 to 2024-03-10.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE training SET date = '2024-03-10' WHERE training_id = 107;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_training_count FROM training WHERE training_id = 107 AND date = '2024-03-10';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_training_count FROM training WHERE training_id = 107 AND date = '2024-03-10';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE training SET date = '2024-04-10' WHERE training_id = 107;"
        ],
        "mysql": [
          "UPDATE training SET date = '2024-04-10' WHERE training_id = 107;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE training SET date = '2024-04-10' WHERE training_id = 107;"
        ],
        "mysql": [
          "UPDATE training SET date = '2024-04-10' WHERE training_id = 107;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "training_id = 107",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 122,
      "nl_prompt": "How to update the location of the company to a new address.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE company SET location = 'Chicago, IL' WHERE company_name = 'PQR Industries';"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_company_count FROM company WHERE company_name = 'PQR Industries' AND location = 'Chicago, IL';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_company_count FROM company WHERE company_name = 'PQR Industries' AND location = 'Chicago, IL';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE company SET location = 'Los Angeles, CA' WHERE company_name = 'PQR Industries';"
        ],
        "mysql": [
          "UPDATE company SET location = 'Los Angeles, CA' WHERE company_name = 'PQR Industries';"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE company SET location = 'Los Angeles, CA' WHERE company_name = 'PQR Industries';"
        ],
        "mysql": [
          "UPDATE company SET location = 'Los Angeles, CA' WHERE company_name = 'PQR Industries';"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "company_name = 'PQR Industries'",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 123,
      "nl_prompt": "Increase the performance rating of employee ID 3536253 to 4.5.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE performance_review SET performance_rating = 4.5 WHERE employee_id = 3536253;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS review_count FROM performance_review WHERE employee_id = 3536253 AND performance_rating = 4.5;"
        ],
        "mysql": [
          "SELECT COUNT(*) AS review_count FROM performance_review WHERE employee_id = 3536253 AND performance_rating = 4.5;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE performance_review SET performance_rating = 3.80 WHERE employee_id = 3536253;"
        ],
        "mysql": [
          "UPDATE performance_review SET performance_rating = 3.80 WHERE employee_id = 3536253;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE performance_review SET performance_rating = 3.80 WHERE employee_id = 3536253;"
        ],
        "mysql": [
          "UPDATE performance_review SET performance_rating = 3.80 WHERE employee_id = 3536253;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "employee_id = 3536253;",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 124,
      "nl_prompt": "How to update the certification expiration date for employee ID 3536258 to 2025-01-01.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee_certification SET expiration_date = '2025-01-01' WHERE employee_id = 3536258;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS certification_count FROM employee_certification WHERE employee_id = 3536258 AND expiration_date = '2025-01-01';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS certification_count FROM employee_certification WHERE employee_id = 3536258 AND expiration_date = '2025-01-01';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee_certification SET expiration_date = '2024-02-18' WHERE employee_id = 3536258;"
        ],
        "mysql": [
          "UPDATE employee_certification SET expiration_date = '2024-02-18' WHERE employee_id = 3536258;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee_certification SET expiration_date = '2024-02-18' WHERE employee_id = 3536258;"
        ],
        "mysql": [
          "UPDATE employee_certification SET expiration_date = '2024-02-18' WHERE employee_id = 3536258;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "employee_id = 3536258",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 125,
      "nl_prompt": "How can i change the travel destination for travel ID 3 to 'Paris, France'.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee_travel SET travel_destination = 'Paris, France' WHERE travel_id = 3;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_travel_rows FROM employee_travel WHERE travel_id = 3 AND travel_destination = 'Paris, France';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_travel_rows FROM employee_travel WHERE travel_id = 3 AND travel_destination = 'Paris, France';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee_travel SET travel_destination = 'Chicago, IL' WHERE travel_id = 3;"
        ],
        "mysql": [
          "UPDATE employee_travel SET travel_destination = 'Chicago, IL' WHERE travel_id = 3;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee_travel SET travel_destination = 'Chicago, IL' WHERE travel_id = 3;"
        ],
        "mysql": [
          "UPDATE employee_travel SET travel_destination = 'Chicago, IL' WHERE travel_id = 3;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "training_id = 3",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 126,
      "nl_prompt": "can we Update the expense amount for expense ID 6 to $15000.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee_business_expense SET expense_amount = 15000 WHERE expense_id = 6;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_expense_rows FROM employee_business_expense WHERE expense_id = 6 AND expense_amount = 15000;"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_expense_rows FROM employee_business_expense WHERE expense_id = 6 AND expense_amount = 15000;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee_business_expense SET expense_amount = '45.75' WHERE expense_id = 6;"
        ],
        "mysql": [
          "UPDATE employee_business_expense SET expense_amount = '45.75' WHERE expense_id = 6;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee_business_expense SET expense_amount = '45.75' WHERE expense_id = 6;"
        ],
        "mysql": [
          "UPDATE employee_business_expense SET expense_amount = '45.75' WHERE expense_id = 6;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "expense_id = 6",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 127,
      "nl_prompt": "How we can update the payment method for payment ID 5 to 'Credit Card'.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE payment SET payment_method = 'Credit Card' WHERE payment_id = 5;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_payment_rows FROM payment WHERE payment_id = 5 AND payment_method = 'Credit Card';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_payment_rows FROM payment WHERE payment_id = 5 AND payment_method = 'Credit Card';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE payment SET payment_method = 'Credit Card' WHERE payment_id = 5;"
        ],
        "mysql": [
          "UPDATE payment SET payment_method = 'Credit Card' WHERE payment_id = 5;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE payment SET payment_method = 'Credit Card' WHERE payment_id = 5;"
        ],
        "mysql": [
          "UPDATE payment SET payment_method = 'Credit Card' WHERE payment_id = 5;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "payment_id = 5",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 128,
      "nl_prompt": "How we can set the status of invoice ID 7 to 'Paid'.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE invoice SET status = 'Paid' WHERE invoice_id = 7;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_invoice_rows FROM invoice WHERE invoice_id = 7 AND status = 'Paid';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_invoice_rows FROM invoice WHERE invoice_id = 7 AND status = 'Paid';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE invoice SET status = 'Pending' WHERE invoice_id = 7;"
        ],
        "mysql": [
          "UPDATE invoice SET status = 'Pending' WHERE invoice_id = 7;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE invoice SET status = 'Pending' WHERE invoice_id = 7;"
        ],
        "mysql": [
          "UPDATE invoice SET status = 'Pending' WHERE invoice_id = 7;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "invoice_id = 7",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 129,
      "nl_prompt": "Changing the termination reason for employee ID 3536257 to 'Resignation'.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee_termination SET reason = 'Resignation' WHERE employee_id = 3536257;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_termination_rows FROM employee_termination WHERE employee_id = 3536257 AND reason = 'Resignation';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_termination_rows FROM employee_termination WHERE employee_id = 3536257 AND reason = 'Resignation';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee_termination SET reason = 'Employee violated company policies and was terminated accordingly.' WHERE employee_id = 3536257;"
        ],
        "mysql": [
          "UPDATE employee_termination SET reason = 'Employee violated company policies and was terminated accordingly.' WHERE employee_id = 3536252;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee_termination SET reason = 'Employee violated company policies and was terminated accordingly.' WHERE employee_id = 3536257;"
        ],
        "mysql": [
          "UPDATE employee_termination SET reason = 'Employee violated company policies and was terminated accordingly.' WHERE employee_id = 3536252;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "employee_id = 3536257",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 130,
      "nl_prompt": "Update the model of the computer with ID 5 to a newer version.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee_computer SET model = 'New Model' WHERE computer_id = 5;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_computer_rows FROM employee_computer WHERE computer_id = 5 AND model = 'New Model';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_computer_rows FROM employee_computer WHERE computer_id = 5 AND model = 'New Model';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee_computer SET model = 'Asus ZenBook' WHERE computer_id = 5;"
        ],
        "mysql": [
          "UPDATE employee_computer SET model = 'Asus ZenBook' WHERE computer_id = 5;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee_computer SET model = 'Asus ZenBook' WHERE computer_id = 5;"
        ],
        "mysql": [
          "UPDATE employee_computer SET model = 'Asus ZenBook' WHERE computer_id = 5;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "computer_id = 5",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 131,
      "nl_prompt": "Modify the description of an allowance with ID 25584 to include additional details.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE allowances SET allowance_description = 'Updated description...' WHERE allowance_id = 25584;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_allowance_rows FROM allowances WHERE allowance_id = 25584 AND allowance_description = 'Updated description...';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_allowance_rows FROM allowances WHERE allowance_id = 25584 AND allowance_description = 'Updated description...';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE allowances SET allowance_description = 'Allowance provided to cover meal expenses for employees.' WHERE allowance_id = 25584;"
        ],
        "mysql": [
          "UPDATE allowances SET allowance_description = 'Allowance provided to cover meal expenses for employees.' WHERE allowance_id = 25584;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE allowances SET allowance_description = 'Allowance provided to cover meal expenses for employees.' WHERE allowance_id = 25584;"
        ],
        "mysql": [
          "UPDATE allowances SET allowance_description = 'Allowance provided to cover meal expenses for employees.' WHERE allowance_id = 25584;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "allowance_id = 25584",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 132,
      "nl_prompt": "Update the working hours for timesheet ID 5 to 8.5.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE timesheet SET working_hours = 8.5 WHERE timesheet_id = 5;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_timesheet_rows FROM timesheet WHERE timesheet_id = 5 AND working_hours = 8.5;"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_timesheet_rows FROM timesheet WHERE timesheet_id = 5 AND working_hours = 9;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE timesheet SET working_hours = 8.5 WHERE timesheet_id = 5;"
        ],
        "mysql": [
          "UPDATE timesheet SET working_hours = 8.5 WHERE timesheet_id = 5;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE timesheet SET working_hours = 8.5 WHERE timesheet_id = 5;"
        ],
        "mysql": [
          "UPDATE timesheet SET working_hours = 8.5 WHERE timesheet_id = 5;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "timesheet_id= 5",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 133,
      "nl_prompt": "Update the employee assigned to timesheet ID 4 to employee ID 3536254.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE timesheet_employee SET employee_id = 3536254 WHERE timesheet_id = 4;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_timesheet_employee_rows FROM timesheet_employee WHERE timesheet_id = 4 AND employee_id = 3536254;"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_timesheet_employee_rows FROM timesheet_employee WHERE timesheet_id = 4 AND employee_id = 3536254;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE timesheet_employee SET employee_id = 3536254 WHERE timesheet_id = 4;"
        ],
        "mysql": [
          "UPDATE timesheet_employee SET employee_id = 3536254 WHERE timesheet_id = 4;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE timesheet_employee SET employee_id = 3536254 WHERE timesheet_id = 4;"
        ],
        "mysql": [
          "UPDATE timesheet_employee SET employee_id = 3536254 WHERE timesheet_id = 4;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "timesheet_id= 5",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 134,
      "nl_prompt": "Retrieve the average number of vacation days requested by employees in each department:",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          "SELECT e.department_id, d.department_name, AVG(lr.duration) AS avg_vacation_days FROM leave_request lr JOIN employee e ON lr.employee_id = e.employee_id JOIN department d ON e.department_id = d.department_id WHERE lr.leave_type = 'Personal Leave' GROUP BY e.department_id, d.department_name"
        ]
      },
      "eval_query": {
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 135,
      "nl_prompt": "Find the employee with the most number of certifications.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, COUNT(certification_id) AS total_certifications FROM employee_certification GROUP BY employee_id ORDER BY COUNT(certification_id) DESC LIMIT 1;"
        ],
        "mysql": [
          "SELECT employee_id, COUNT(certification_id) AS total_certifications FROM employee_certification GROUP BY employee_id ORDER BY COUNT(certification_id) DESC LIMIT 1"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 144,
      "nl_prompt": "Retrieve the total number of certifications held by each employee.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, COUNT(certification_id) AS total_certifications FROM employee_certification GROUP BY employee_id;"
        ],
        "mysql": [
          "SELECT employee_id, COUNT(certification_id) AS total_certifications FROM employee_certification GROUP BY employee_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "difficulty: simple"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 137,
      "nl_prompt": "Calculate the difference between an employees salary and the average salary in their department.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, s.salary, s.salary - AVG(s.salary) OVER (PARTITION BY e.department_id) AS salary_difference FROM employee e JOIN salary s ON e.employee_id = s.employee_id;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, s.salary, s.salary - AVG(s.salary) OVER (PARTITION BY e.department_id) AS salary_difference FROM employee e JOIN salary s ON e.employee_id = s.employee_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 138,
      "nl_prompt": "Rank departments based on their budget in descending order.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT department_id, department_name, budget, RANK() OVER (ORDER BY budget DESC) AS budget_rank FROM department;"
        ],
        "mysql": [
          "SELECT department_id, department_name, budget, RANK() OVER (ORDER BY budget DESC) AS budget_rank FROM department;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "RANK"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 139,
      "nl_prompt": "Determine the percentage of total expenses each employees expenses represent.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, expense_amount, (expense_amount / total_expenses) * 100 AS expense_percentage FROM employee_business_expense, (SELECT SUM(expense_amount) AS total_expenses FROM employee_business_expense) AS total_expenses_subquery;"
        ],
        "mysql": [
          "SELECT employee_id, expense_amount, (expense_amount / total_expenses) * 100 AS expense_percentage FROM employee_business_expense, (SELECT SUM(expense_amount) AS total_expenses FROM employee_business_expense) AS total_expenses_subquery;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 140,
      "nl_prompt": "Identify the employee with the longest tenure in the company.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, first_name, last_name, hire_date FROM ( SELECT employee_id, first_name, last_name, hire_date, DENSE_RANK() OVER (ORDER BY hire_date) AS tenure_rank FROM employee ) AS ranked_employees WHERE tenure_rank = 1;"
        ],
        "mysql": [
          "SELECT employee_id, first_name, last_name, hire_date FROM ( SELECT employee_id, first_name, last_name, hire_date, DENSE_RANK() OVER (ORDER BY hire_date) AS tenure_rank FROM employee ) AS ranked_employees WHERE tenure_rank = 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "DENSE_RANK"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 141,
      "nl_prompt": "Find the cumulative sum of expenses for each employee over time.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, expense_date, expense_amount, SUM(expense_amount) OVER (PARTITION BY employee_id ORDER BY expense_date) AS cumulative_expenses FROM employee_business_expense;"
        ],
        "mysql": [
          "SELECT employee_id, expense_date, expense_amount, SUM(expense_amount) OVER (PARTITION BY employee_id ORDER BY expense_date) AS cumulative_expenses FROM employee_business_expense;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "PARTITION"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 142,
      "nl_prompt": "Rank employees based on their salaries within each department.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, e.department_id, RANK() OVER (PARTITION BY e.department_id ORDER BY s.salary DESC) AS salary_rank FROM employee e JOIN salary s ON e.employee_id = s.employee_id;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, e.department_id, RANK() OVER (PARTITION BY e.department_id ORDER BY s.salary DESC) AS salary_rank FROM employee e JOIN salary s ON e.employee_id = s.employee_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "RANK",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 143,
      "nl_prompt": "Find the maximum budget among all departments.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT MAX(budget) AS max_budget FROM department;"
        ],
        "mysql": [
          "SELECT MAX(budget) AS max_budget FROM department;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 145,
      "nl_prompt": "Find the total number of leave days requested by each employee.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, SUM(duration) AS total_leave_days FROM leave_request GROUP BY employee_id;"
        ],
        "mysql": [
          "SELECT employee_id, SUM(duration) AS total_leave_days FROM leave_request GROUP BY employee_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 146,
      "nl_prompt": "Calculate the total expenses incurred by each employee by summing their business expenses.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, COALESCE(SUM(ebe.expense_amount), 0) AS total_expenses FROM employee e LEFT JOIN employee_business_expense ebe ON e.employee_id = ebe.employee_id GROUP BY e.employee_id, e.first_name, e.last_name;"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name, COALESCE(SUM(ebe.expense_amount), 0) AS total_expenses FROM employee e LEFT JOIN employee_business_expense ebe ON e.employee_id = ebe.employee_id GROUP BY e.employee_id, e.first_name, e.last_name;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "COALESCE",
        "AGGREGATE",
        "LEFT_JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 147,
      "nl_prompt": "Retrieve the duration of each training session by calculating the difference between start and end dates.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT training_id, title, date, date - CURRENT_DATE AS duration_days FROM training;"
        ],
        "mysql": [
          "SELECT training_id, title, date, DATEDIFF(date, current_date()) AS duration_days FROM training;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 148,
      "nl_prompt": "Find the number of days each employee has been employed in the company.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, first_name, last_name, hire_date, CURRENT_DATE - hire_date AS days_employed FROM employee;"
        ],
        "mysql": [
          "SELECT employee_id, first_name, last_name, hire_date, DATEDIFF(CURDATE(), hire_date) AS days_employed FROM employee;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 149,
      "nl_prompt": "Retrieve the full name of each employee by concatenating their first name and last name.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, CONCAT(first_name, ' ', last_name) AS full_name FROM employee;"
        ],
        "mysql": [
          "SELECT employee_id, CONCAT(first_name, ' ', last_name) AS full_name FROM employee;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "CONCAT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 150,
      "nl_prompt": "Calculate the age of each employee based on their date of birth.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, first_name, last_name, date_of_birth, EXTRACT(YEAR FROM AGE(CURRENT_DATE, date_of_birth)) AS age FROM employee;"
        ],
        "mysql": [
          "SELECT employee_id, first_name, last_name, date_of_birth, TIMESTAMPDIFF(YEAR, date_of_birth, CURDATE()) AS age FROM employee;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 151,
      "nl_prompt": "Retrieve employees who have been assigned computers with either Dell or HP models.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name FROM employee e WHERE EXISTS ( SELECT 1 FROM employee_computer ec WHERE ec.employee_id = e.employee_id AND ec.model IN ('Dell XPS 15', 'HP Pavilion') );"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name FROM employee e WHERE EXISTS ( SELECT 1 FROM employee_computer ec WHERE ec.employee_id = e.employee_id AND ec.model IN ('Dell XPS 15', 'HP Pavilion') );"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT"
      ],
      "other": {
        "Extra context": "model IN ('Dell XPS 15', 'HP Pavilion')",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 152,
      "nl_prompt": "Retrieve employees who have allowances for either Transportation or Housing.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name FROM employee e WHERE EXISTS ( SELECT 1 FROM employee_allowances ea JOIN allowances a ON ea.allowance_id = a.allowance_id WHERE ea.employee_id = e.employee_id AND a.allowance IN ('Transport Allowance', 'Housing Allowance') );"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name FROM employee e WHERE EXISTS ( SELECT 1 FROM employee_allowances ea JOIN allowances a ON ea.allowance_id = a.allowance_id WHERE ea.employee_id = e.employee_id AND a.allowance IN ('Transport Allowance', 'Housing Allowance') );"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT"
      ],
      "other": {
        "Extra context": "allowance IN ('Transport Allowance', 'Housing Allowance')",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 153,
      "nl_prompt": "Find employees who have expenses in categories related to either Travel or Meals.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name FROM employee e WHERE EXISTS ( SELECT 1 FROM employee_business_expense ebe WHERE ebe.employee_id = e.employee_id AND ebe.expense_category IN ('Travel', 'Meals') );"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name FROM employee e WHERE EXISTS ( SELECT 1 FROM employee_business_expense ebe WHERE ebe.employee_id = e.employee_id AND ebe.expense_category IN ('Travel', 'Meals') );"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT"
      ],
      "other": {
        "Extra context": "expense_category IN ('Travel', 'Meals')",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 154,
      "nl_prompt": "Retrieve employees who have attended trainings related to either Leadership or Communication.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name FROM employee e WHERE EXISTS ( SELECT 1 FROM employee_training et JOIN training t ON et.training_id = t.training_id WHERE et.employee_id = e.employee_id AND t.title IN ('Leadership Development Seminar', 'Sales Techniques Workshop') );"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name FROM employee e WHERE EXISTS ( SELECT 1 FROM employee_training et JOIN training t ON et.training_id = t.training_id WHERE et.employee_id = e.employee_id AND t.title IN ('Leadership Development Seminar', 'Sales Techniques Workshop') );"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Extra context": "title in ('Leadership Development Seminar', 'Sales Techniques Workshop')",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 155,
      "nl_prompt": "Find departments where employees are eligible for either Stock Options or Bonus Programs.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT d.department_id, d.department_name FROM department d WHERE EXISTS ( SELECT 1 FROM employee e WHERE e.department_id = d.department_id AND EXISTS ( SELECT 1 FROM employee_x_benefit xb JOIN benefit b ON xb.benefit_id = b.benefit_id WHERE xb.employee_id = e.employee_id AND b.benefit_name IN ('Stock Options', 'Bonus Programs') ) );"
        ],
        "mysql": [
          "SELECT d.department_id, d.department_name FROM department d WHERE EXISTS ( SELECT 1 FROM employee e WHERE e.department_id = d.department_id AND EXISTS ( SELECT 1 FROM employee_x_benefit xb JOIN benefit b ON xb.benefit_id = b.benefit_id WHERE xb.employee_id = e.employee_id AND b.benefit_name IN ('Stock Options', 'Bonus Programs') ) );"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Extra context": "benefit_name IN ('Stock Options', 'Bonus Programs')",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 156,
      "nl_prompt": "Retrieve employees who have benefits related to either Health Insurance or Retirement Plan.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name FROM employee e WHERE EXISTS ( SELECT 1 FROM employee_x_benefit xb JOIN benefit b ON xb.benefit_id = b.benefit_id WHERE xb.employee_id = e.employee_id AND b.benefit_name IN ('Health Insurance', 'Retirement Plan') );"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name FROM employee e WHERE EXISTS ( SELECT 1 FROM employee_x_benefit xb JOIN benefit b ON xb.benefit_id = b.benefit_id WHERE xb.employee_id = e.employee_id AND b.benefit_name IN ('Health Insurance', 'Retirement Plan') );"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Extra context": "benefit_name IN ('Health Insurance', 'Retirement Plan')",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 157,
      "nl_prompt": "Find employees who have certifications from either AWS or Microsoft.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name FROM employee e WHERE EXISTS ( SELECT 1 FROM employee_certification ec WHERE ec.employee_id = e.employee_id AND ec.issuing_organization IN ('AWS', 'Microsoft') );"
        ],
        "mysql": [
          "SELECT e.employee_id, e.first_name, e.last_name FROM employee e WHERE EXISTS ( SELECT 1 FROM employee_certification ec WHERE ec.employee_id = e.employee_id AND ec.issuing_organization IN ('AWS', 'Microsoft') );"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT"
      ],
      "other": {
        "Extra context": "issuing_organization IN ('AWS', 'Microsoft')",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 158,
      "nl_prompt": "Retrieve employees who have skills in either Business Intelligence or selenium.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          "SELECT employee_id, first_name, last_name FROM employee WHERE job_id IN ( SELECT job_id FROM job WHERE skills_preferred like '%Mark%' );"
        ]
      },
      "eval_query": {
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT"
      ],
      "other": {
        "Extra context": "skills_preferred like '%Business Intelligence%' OR skills_preferred like '%Selenium%'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 159,
      "nl_prompt": "Adjust the salary of employees in departments with a budget increase of more than 15% to maintain a 20% salary-to-budget ratio.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE salary SET salary = salary * 1.2 WHERE employee_id IN ( SELECT e.employee_id FROM employee e INNER JOIN department d ON e.department_id = d.department_id WHERE (d.budget - (SELECT budget FROM department WHERE department_id = d.department_id)) / d.budget > 0.15 );"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_salary_rows FROM salary s WHERE s.employee_id IN ( SELECT e.employee_id FROM employee e INNER JOIN department d ON e.department_id = d.department_id WHERE (d.budget - (SELECT budget FROM department WHERE department_id = d.department_id)) / d.budget > 0.15 );"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_salary_rows FROM salary s WHERE s.employee_id IN ( SELECT e.employee_id FROM employee e INNER JOIN department d ON e.department_id = d.department_id WHERE (d.budget - (SELECT budget FROM department WHERE department_id = d.department_id)) / d.budget > 0.15 );"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE salary SET salary = salary / 1.2 WHERE employee_id IN ( SELECT e.employee_id FROM employee e INNER JOIN department d ON e.department_id = d.department_id WHERE (d.budget - (SELECT budget FROM department WHERE department_id = d.department_id)) / d.budget > 0.15 );"
        ],
        "mysql": [
          "UPDATE salary SET salary = salary / 1.2 WHERE employee_id IN ( SELECT e.employee_id FROM employee e INNER JOIN department d ON e.department_id = d.department_id WHERE (d.budget - (SELECT MAX(budget) FROM department WHERE department_id = d.department_id)) / d.budget > 0.15 );"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE salary SET salary = salary / 1.2 WHERE employee_id IN ( SELECT e.employee_id FROM employee e INNER JOIN department d ON e.department_id = d.department_id WHERE (d.budget - (SELECT budget FROM department WHERE department_id = d.department_id)) / d.budget > 0.15 );"
        ],
        "mysql": [
          "UPDATE salary SET salary = salary / 1.2 WHERE employee_id IN ( SELECT e.employee_id FROM employee e INNER JOIN department d ON e.department_id = d.department_id WHERE (d.budget - (SELECT MAX(budget) FROM department WHERE department_id = d.department_id)) / d.budget > 0.15 );"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 160,
      "nl_prompt": "Update the benefits coverage for employees who have recently completed 'Software Development Best Practices'' training programs.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "mysql": [
          "SELECT COUNT(*) AS updated_benefit_rows FROM employee_x_benefit WHERE employee_id IN ( SELECT employee_id FROM employee_training WHERE training_id IN ( SELECT training_id FROM training WHERE title = 'Software Development Best Practices' ) );"
        ]
      },
      "setup_sql": {
        "mysql": [
          "UPDATE employee_x_benefit SET end_date = '2022-12-31' WHERE employee_id IN ( SELECT employee_id FROM employee_training WHERE training_id IN ( SELECT training_id FROM training WHERE title = 'Software Development Best Practices' ) );"
        ]
      },
      "cleanup_sql": {
        "mysql": [
          "UPDATE employee_x_benefit SET end_date = '2022-12-31' WHERE employee_id IN ( SELECT employee_id FROM employee_training WHERE training_id IN ( SELECT training_id FROM training WHERE title = 'Software Development Best Practices' ) );"
        ]
      },
      "tags": [
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "UPDATE",
        "SELECT"
      ],
      "other": {
        "Extra context": "title = 'Software Development Best Practices'",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 161,
      "nl_prompt": "Update the hire date of the benefit coverage for employees with certifications from a ''Project Management Institute' issuing organization.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "mysql": [
          "SELECT COUNT(*) AS updated_coverage_rows FROM employee WHERE employee_id IN ( SELECT ec.employee_id FROM employee_certification ec WHERE ec.issuing_organization = 'Project Management Institute' );"
        ]
      },
      "setup_sql": {
        "mysql": [
          "UPDATE employee SET hire_date = '2023-02-28' WHERE employee_id IN ( SELECT ec.employee_id FROM employee_certification ec WHERE ec.issuing_organization = 'Project Management Institute' );"
        ]
      },
      "cleanup_sql": {
        "mysql": [
          "UPDATE employee SET hire_date = '2023-02-28' WHERE employee_id IN ( SELECT ec.employee_id FROM employee_certification ec WHERE ec.issuing_organization = 'Project Management Institute' );"
        ]
      },
      "tags": [
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE",
        "SELECT"
      ],
      "other": {
        "Extra context": "issuing_organization = 'Project Management Institute' );",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 162,
      "nl_prompt": "Update the salary of employees within the Finance department to reflect a 10% raise.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE salary SET salary = salary * 1.1 WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Finance') );"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_salary_rows FROM salary s WHERE s.employee_id IN ( SELECT e.employee_id FROM employee e WHERE e.department_id = (SELECT department_id FROM department WHERE department_name = 'Finance') );"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_salary_rows FROM salary s WHERE s.employee_id IN ( SELECT e.employee_id FROM employee e WHERE e.department_id = (SELECT department_id FROM department WHERE department_name = 'Finance') );"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE salary SET salary = salary / 1.1 WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Finance') );"
        ],
        "mysql": [
          "UPDATE salary SET salary = salary / 1.1 WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Finance') );"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE salary SET salary = salary / 1.1 WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Finance') );"
        ],
        "mysql": [
          "UPDATE salary SET salary = salary / 1.1 WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Finance') );"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE",
        "SELECT"
      ],
      "other": {
        "Extra context": "department_name = 'Finance'",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 163,
      "nl_prompt": "Extend the end date of the training sessions attended by employees within the Sales department to 2024-03-15.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE training SET date = '2024-03-15' WHERE training_id IN ( SELECT et.training_id FROM employee_training et JOIN employee e ON et.employee_id = e.employee_id WHERE e.department_id = (SELECT department_id FROM department WHERE department_name = 'Sales') );"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_training_rows FROM training t WHERE t.training_id IN ( SELECT et.training_id FROM employee_training et WHERE et.employee_id IN ( SELECT e.employee_id FROM employee e WHERE e.department_id = (SELECT department_id FROM department WHERE department_name = 'Sales') ) );"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_training_rows FROM training t WHERE t.training_id IN ( SELECT et.training_id FROM employee_training et WHERE et.employee_id IN ( SELECT e.employee_id FROM employee e WHERE e.department_id = (SELECT department_id FROM department WHERE department_name = 'Sales') ) );"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE training SET date = '2024-03-15' WHERE training_id IN ( SELECT training_id FROM employee_training WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Sales') ) );"
        ],
        "mysql": [
          "UPDATE training SET date = '2024-03-15' WHERE training_id IN ( SELECT training_id FROM employee_training WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Sales') ) );"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE training SET date = '2024-03-15' WHERE training_id IN ( SELECT training_id FROM employee_training WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Sales') ) );"
        ],
        "mysql": [
          "UPDATE training SET date = '2024-03-15' WHERE training_id IN ( SELECT training_id FROM employee_training WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Sales') ) );"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "UPDATE",
        "SELECT"
      ],
      "other": {
        "Extra context": "department_name = 'Sales'",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 164,
      "nl_prompt": "Update the performance rating of employees within the HR department who have a rating below 4.0 to 4.0.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE performance_review SET performance_rating = 4.0 WHERE employee_id IN ( SELECT e.employee_id FROM employee e JOIN department d ON e.department_id = d.department_id WHERE d.department_name = 'Human Resources' ) AND performance_rating < 4.0;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_review_rows FROM performance_review pr WHERE pr.employee_id IN ( SELECT e.employee_id FROM employee e WHERE e.department_id = (SELECT department_id FROM department WHERE department_name = 'Human Resources') ) AND pr.performance_rating < 4.0;"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_review_rows FROM performance_review pr WHERE pr.employee_id IN ( SELECT e.employee_id FROM employee e WHERE e.department_id = (SELECT department_id FROM department WHERE department_name = 'Human Resources') ) AND pr.performance_rating < 4.0;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE performance_review SET performance_rating = 3.80 WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Human Resources') ) AND performance_rating < 4.0;"
        ],
        "mysql": [
          "UPDATE performance_review SET performance_rating = 3.80 WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = ( SELECT department_id FROM department WHERE department_name = 'Human Resources' LIMIT 1 ) ) AND performance_rating = 4.0;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE performance_review SET performance_rating = 3.80 WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Human Resources') ) AND performance_rating < 4.0;"
        ],
        "mysql": [
          "UPDATE performance_review SET performance_rating = 3.80 WHERE employee_id IN ( SELECT employee_id FROM employee WHERE department_id = ( SELECT department_id FROM department WHERE department_name = 'Human Resources' LIMIT 1 ) ) AND performance_rating = 4.0;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "UPDATE",
        "SELECT"
      ],
      "other": {
        "Extra context": "department_name = 'Human Resources'",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 165,
      "nl_prompt": "Update the job title and minimum salary of the positions within the Sales department to reflect new roles and compensation.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE job SET job_title = 'Senior Sales Executive', min_salary = 60000 WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Sales');"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_job_rows FROM job WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Sales');"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_job_rows FROM job WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Sales');"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE job SET job_title = CASE WHEN job_id = 4 THEN 'Sales Representative' WHEN job_id = 13 THEN 'Technical Support Specialist' WHEN job_id = 15 THEN 'Network Administrator' WHEN job_id = 19 THEN 'IT Support Specialist' END, min_salary = CASE WHEN job_id = 4 THEN 50000.00 WHEN job_id = 13 THEN 40000.00 WHEN job_id = 15 THEN 55000.00 WHEN job_id = 19 THEN 45000.00 END WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Sales');"
        ],
        "mysql": [
          "UPDATE job SET job_title = CASE WHEN job_id = 4 THEN 'Sales Representative' WHEN job_id = 13 THEN 'Technical Support Specialist' WHEN job_id = 15 THEN 'Network Administrator' WHEN job_id = 19 THEN 'IT Support Specialist' END, min_salary = CASE WHEN job_id = 4 THEN 50000.00 WHEN job_id = 13 THEN 40000.00 WHEN job_id = 15 THEN 55000.00 WHEN job_id = 19 THEN 45000.00 END WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Sales');"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE job SET job_title = CASE WHEN job_id = 4 THEN 'Sales Representative' WHEN job_id = 13 THEN 'Technical Support Specialist' WHEN job_id = 15 THEN 'Network Administrator' WHEN job_id = 19 THEN 'IT Support Specialist' END, min_salary = CASE WHEN job_id = 4 THEN 50000.00 WHEN job_id = 13 THEN 40000.00 WHEN job_id = 15 THEN 55000.00 WHEN job_id = 19 THEN 45000.00 END WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Sales');"
        ],
        "mysql": [
          "UPDATE job SET job_title = CASE WHEN job_id = 4 THEN 'Sales Representative' WHEN job_id = 13 THEN 'Technical Support Specialist' WHEN job_id = 15 THEN 'Network Administrator' WHEN job_id = 19 THEN 'IT Support Specialist' END, min_salary = CASE WHEN job_id = 4 THEN 50000.00 WHEN job_id = 13 THEN 40000.00 WHEN job_id = 15 THEN 55000.00 WHEN job_id = 19 THEN 45000.00 END WHERE department_id = (SELECT department_id FROM department WHERE department_name = 'Sales');"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE",
        "SELECT"
      ],
      "other": {
        "Extra context": "department_name= 'Sales'",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 166,
      "nl_prompt": "Update the budget of the HR department to $120000 and change the manager to employee with ID 208.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "mysql": [
          "SELECT COUNT(*) AS updated_department_rows FROM department WHERE department_name = 'Human Resources';"
        ]
      },
      "setup_sql": {
        "mysql": [
          "UPDATE department SET budget = '100000.00', manager_id = '3536251' WHERE department_name = 'Human Resources';"
        ]
      },
      "cleanup_sql": {
        "mysql": [
          "UPDATE department SET budget = '100000.00', manager_id = '3536251' WHERE department_name = 'Human Resources';"
        ]
      },
      "tags": [
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "department_name = 'Human Resources'",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 167,
      "nl_prompt": "Update the end date of the salary record for employee ID 501 to 2024-02-28.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE salary SET end_date = '2024-02-28' WHERE employee_id = 3536259;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_salary_rows FROM salary WHERE employee_id = 3536259;"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_salary_rows FROM salary WHERE employee_id = 3536259;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE salary SET end_date = NULL WHERE employee_id = 3536259;"
        ],
        "mysql": [
          "UPDATE salary SET end_date = NULL WHERE employee_id = 3536259;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE salary SET end_date = NULL WHERE employee_id = 3536259;"
        ],
        "mysql": [
          "UPDATE salary SET end_date = NULL WHERE employee_id = 3536259;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "employee_id = 3536259",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 168,
      "nl_prompt": "Extend the join date of the employment contract for employee ID 401 to 2025-01-01.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee SET hire_date = '2025-01-01' WHERE employee_id = 3536257;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_employee_rows FROM employee WHERE employee_id = 3536257 ;"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_employee_rows FROM employee WHERE employee_id = 3536257 ;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee SET hire_date = '2023-07-10' WHERE employee_id = 3536257;"
        ],
        "mysql": [
          "UPDATE employee SET hire_date = '2023-07-10' WHERE employee_id = 3536257;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee SET hire_date = '2023-07-10' WHERE employee_id = 3536257;"
        ],
        "mysql": [
          "UPDATE employee SET hire_date = '2023-07-10' WHERE employee_id = 3536257;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "employee_id = 3536259",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 169,
      "nl_prompt": "Adjust the start date of the contract for employee ID 3536253 to 2024-03-01.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee SET hire_date = '2024-03-01' WHERE employee_id = 3536253;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_employee_rows FROM employee WHERE employee_id = 3536253 AND hire_date = '2024-03-01';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_employee_rows FROM employee WHERE employee_id = 3536253 AND hire_date = '2024-03-01';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee SET hire_date = '2023-02-28' WHERE employee_id = 3536253;"
        ],
        "mysql": [
          "UPDATE employee SET hire_date = '2023-02-28' WHERE employee_id = 3536253;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee SET hire_date = '2023-02-28' WHERE employee_id = 3536253;"
        ],
        "mysql": [
          "UPDATE employee SET hire_date = '2023-02-28' WHERE employee_id = 3536253;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "employee_id = 3536259",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 170,
      "nl_prompt": "Update the amount of an employee allowance with ID 5 to $200.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee_allowances SET amount = 200 WHERE employee_allowance_id = 5;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_employee_allowances_rows FROM employee_allowances WHERE employee_allowance_id = 5;"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_employee_allowances_rows FROM employee_allowances WHERE employee_allowance_id = 5;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee_allowances SET amount = '600.00' WHERE employee_allowance_id = 5;"
        ],
        "mysql": [
          "UPDATE employee_allowances SET amount = '600.00' WHERE employee_allowance_id = 5;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee_allowances SET amount = '600.00' WHERE employee_allowance_id = 5;"
        ],
        "mysql": [
          "UPDATE employee_allowances SET amount = '600.00' WHERE employee_allowance_id = 5;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "employee_allowance_id= 5",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 171,
      "nl_prompt": "Change the occasion of the holiday on 2024-12-25 to 'Christmas Day'.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE holiday SET occasion = 'Christmas Day' WHERE date = '2024-12-25';"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_holiday_rows FROM holiday WHERE date = '2024-12-25';"
        ],
        "mysql": [
          "SELECT COUNT(*) AS updated_holiday_rows FROM holiday WHERE date = '2024-12-25';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE holiday SET occasion = 'Christmas Day' WHERE date = '2024-12-25';"
        ],
        "mysql": [
          "UPDATE holiday SET occasion = 'Christmas Day' WHERE date = '2024-12-25';"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE holiday SET occasion = 'Christmas Day' WHERE date = '2024-12-25';"
        ],
        "mysql": [
          "UPDATE holiday SET occasion = 'Christmas Day' WHERE date = '2024-12-25';"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0,
        "Extra context": "date= '2024-12-25'"
      }
    },
    {
      "id": 172,
      "nl_prompt": "Retrieve the address details (street, city, state, zip code) for a 3536259 employee.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          "SELECT address->>'$.street' AS street, address->>'$.city' AS city, address->>'$.state' AS state, address->>'$.zip_code' AS zip_code FROM employee WHERE employee_id = 3536259;"
        ]
      },
      "eval_query": {
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JSON"
      ],
      "other": {
        "Extra context": "employee_id = 3536259",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 173,
      "nl_prompt": "Provide the bank account details (account number, bank name, branch) for a particular employee.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT bank_account_number->>'account_number' AS account_number, bank_account_number->>'bank_name' AS bank_name, bank_account_number->>'branch' AS branch FROM employee WHERE employee_id = 3536259;"
        ],
        "mysql": [
          "SELECT bank_account_number->>'$.account_number' AS account_number, bank_account_number->>'$.bank_name' AS bank_name, bank_account_number->>'$.branch' AS branch FROM employee WHERE employee_id = 3536259;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JSON"
      ],
      "other": {
        "Extra context": "employee_id = 3536259",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 174,
      "nl_prompt": "Get the emergency contact information (name, phone number) for an employee.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT emergency_contact_name, emergency_contact_number FROM employee WHERE employee_id = 3536258;"
        ],
        "mysql": [
          "SELECT emergency_contact_name, emergency_contact_number FROM employee WHERE employee_id = 3536258;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT"
      ],
      "other": {
        "Extra context": "employee_id = 3536259",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 175,
      "nl_prompt": "Retrieve the skills required for a particular job.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT skills_required FROM job WHERE job_title = 'Software Engineer';"
        ],
        "mysql": [
          "SELECT skills_required FROM job WHERE job_title = 'Software Engineer';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT"
      ],
      "other": {
        "Extra context": "job_title = 'Software Engineer'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 176,
      "nl_prompt": "Retrieve the names of employees who live in a Newtown city .",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "mysql"
      ],
      "golden_sql": {
        "mysql": [
          "SELECT first_name, last_name,address FROM employee WHERE address->>'$.city' = 'Newtown';"
        ]
      },
      "eval_query": {
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT"
      ],
      "other": {
        "Extra context": "address->>'$.city' = 'Newtown'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 177,
      "nl_prompt": "Retrieve the names of employees who have skills in a Java programming language.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT a.first_name, a.last_name, b.skills_required FROM employee a INNER JOIN job b ON a.job_id = b.job_id WHERE b.skills_required ->> 'Java' = 'Advanced';"
        ],
        "mysql": [
          "SELECT a.first_name, a.last_name, b.skills_required FROM employee a INNER JOIN job b ON a.job_id = b.job_id WHERE JSON_SEARCH(b.skills_required, 'one', 'Advanced') IS NOT NULL;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "JSON_SEARCH"
      ],
      "other": {
        "Extra context": "skills_required ->> 'Java' = 'Advanced'",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 178,
      "nl_prompt": "Retrieve the names of active departments with a total budget exceeding 100 thousand dollars.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT department_name FROM department WHERE is_active = true AND budget > 100000;"
        ],
        "mysql": [
          "SELECT department_name FROM department WHERE is_active = 1 AND budget > 100000;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT"
      ],
      "other": {
        "Extra context": "budget > 1000000",
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 179,
      "nl_prompt": "Retrieve job titles where 'Marketing' is listed as a preferred skill.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT job_title, skills_preferred FROM job WHERE skills_preferred @> '{\"Email Marketing\": \"Intermediate\"}'::jsonb;"
        ],
        "mysql": [
          "SELECT job_title, JSON_EXTRACT(skills_preferred, '$.\"Digital Marketing\"') AS digital_marketing_proficiency FROM job;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JSON_SEARCH"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 180,
      "nl_prompt": "Retrieve the names of benefits that cover dental expenses.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT title FROM training WHERE attendance_required = TRUE;"
        ],
        "mysql": [
          "SELECT title FROM training WHERE attendance_required = TRUE;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 181,
      "nl_prompt": "Show the status and total amount of unpaid invoices",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT status, SUM(total_amount) AS total_unpaid_amount FROM invoice WHERE status <> 'Paid' GROUP BY status;"
        ],
        "mysql": [
          "SELECT status, SUM(total_amount) AS total_unpaid_amount FROM invoice WHERE status <> 'Paid' GROUP BY status;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 182,
      "nl_prompt": "Calculate the total business expenses for each employee.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT ebe.employee_id, SUM(expense_amount) AS total_business_expenses FROM employee_business_expense ebe GROUP BY ebe.employee_id;"
        ],
        "mysql": [
          "SELECT ebe.employee_id, SUM(expense_amount) AS total_business_expenses FROM employee_business_expense ebe GROUP BY ebe.employee_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 183,
      "nl_prompt": "Find companies with names ending in \"solu\"",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT * FROM company WHERE LOWER(company_name) LIKE '%solu%';"
        ],
        "mysql": [
          "SELECT * FROM company WHERE LOWER(company_name) LIKE '%solu%';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "STRING"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 184,
      "nl_prompt": "Display leave requests with reasons containing the word \"vacation",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT * FROM leave_request WHERE LOWER(reason) LIKE '%vacation%';"
        ],
        "mysql": [
          "SELECT * FROM leave_request WHERE LOWER(reason) LIKE '%vacation%';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "STRING",
        "LIKE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 185,
      "nl_prompt": "Find benefits with names starting with \"Health\"",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT * FROM benefit WHERE LOWER(benefit_name) LIKE 'health%';"
        ],
        "mysql": [
          "SELECT * FROM benefit WHERE LOWER(benefit_name) LIKE 'health%';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "STRING",
        "LIKE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 186,
      "nl_prompt": "Display employee IDs and their masked bank account numbers",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, CONCAT('XXXX-XXXX-XXXX-', RIGHT(bank_account_number->>'$.account_number', 4)) AS masked_account_number FROM employee;"
        ],
        "mysql": [
          "SELECT employee_id, CONCAT('XXXX-XXXX-XXXX-', RIGHT(bank_account_number->>'$.account_number', 4)) AS masked_account_number FROM employee;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "STRING"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 187,
      "nl_prompt": "Retrieve the full name of employees with their email domains",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT CONCAT(first_name, ' ', last_name) AS full_name, SPLIT_PART(email, '@', 2) AS email_domain FROM employee;"
        ],
        "mysql": [
          "SELECT CONCAT(first_name, ' ', last_name) AS full_name, SUBSTRING_INDEX(email, '@', -1) AS email_domain FROM employee;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ],
        "mysql": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "STRING"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 188,
      "nl_prompt": "Update the address of an employee with employee_id. Set the city to \"New City\" and update the postal code.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee SET address = jsonb_set( jsonb_set(address, '{city}', '\"New City\"', true), '{postal_code}', '\"12345\"', true ) WHERE employee_id = 3536259;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM employee WHERE employee_id = 3536259 AND address = JSONB_SET( JSONB_SET(address, '{city}', '\"New City\"', true), '{postal_code}', '\"12345\"', true );"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM employee WHERE employee_id = 3536259 AND JSON_CONTAINS(address, '{\"city\": \"New City\", \"postal_code\": \"12345\"}');"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee SET address = '{\"zip\": \"12345\", \"city\": \"Newtown\", \"state\": \"WA\", \"street\": \"444 Cedar St\"}' WHERE employee_id = 3536259;"
        ],
        "mysql": [
          "UPDATE employee SET address = '{\"zip\": \"12345\", \"city\": \"Newtown\", \"state\": \"WA\", \"street\": \"444 Cedar St\"}' WHERE employee_id = 3536259;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee SET address = '{\"zip\": \"12345\", \"city\": \"Newtown\", \"state\": \"WA\", \"street\": \"444 Cedar St\"}' WHERE employee_id = 3536259;"
        ],
        "mysql": [
          "UPDATE employee SET address = '{\"zip\": \"12345\", \"city\": \"Newtown\", \"state\": \"WA\", \"street\": \"444 Cedar St\"}' WHERE employee_id = 3536259;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "UPDATE",
        "JSON_SET"
      ],
      "other": {
        "Extra context": "employee_id = 3536259",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 189,
      "nl_prompt": "Update the responsibilities of a job with job_id. Add a new skill requirement \"JavaScript\" to the existing skills.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE job SET responsibilities = 'Respond to customer inquiries, resolve issues via phone, email, or chat.' WHERE job_id = 8;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM job WHERE job_id = 8 AND responsibilities = 'Respond to customer inquiries, resolve issues via phone, email, or chat.';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM job WHERE job_id = 8 AND responsibilities = 'Respond to customer inquiries, resolve issues via phone, email, or chat.';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE job SET responsibilities = 'Respond to customer inquiries resolve issues via phone email or chat.' WHERE job_id = 8;"
        ],
        "mysql": [
          "UPDATE job SET responsibilities = 'Respond to customer inquiries resolve issues via phone email or chat.' WHERE job_id = 8;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE job SET responsibilities = 'Respond to customer inquiries resolve issues via phone email or chat.' WHERE job_id = 8;"
        ],
        "mysql": [
          "UPDATE job SET responsibilities = 'Respond to customer inquiries resolve issues via phone email or chat.' WHERE job_id = 8;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE",
        "JSON_INSERT"
      ],
      "other": {
        "Extra context": "job_id= 8",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 190,
      "nl_prompt": "Update the bank account number of an employee with employee_id. Change the last four digits of the account number to \"9876\".",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee SET bank_account_number = JSONB_SET( bank_account_number, '{account_number}', '\"XXXX-XXXX-XXXX-9876\"' ) WHERE employee_id = 3536256;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM employee WHERE employee_id = 3536256 AND bank_account_number = JSONB_SET(bank_account_number, '{account_number}', '\"XXXX-XXXX-XXXX-9876\"');"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM employee WHERE employee_id = 3536256 AND JSON_CONTAINS(bank_account_number, '\"XXXX-XXXX-XXXX-9876\"', '$.account_number');"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee SET bank_account_number = '{\"bank_name\": \"Bank Example\", \"account_number\": \"9876543210\", \"routing_number\": \"0123456789\"}' WHERE employee_id = 3536256;"
        ],
        "mysql": [
          "UPDATE employee SET bank_account_number = '{\"bank_name\": \"Bank Example\", \"account_number\": \"9876543210\", \"routing_number\": \"0123456789\"}' WHERE employee_id = 3536256;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee SET bank_account_number = '{\"bank_name\": \"Bank Example\", \"account_number\": \"9876543210\", \"routing_number\": \"0123456789\"}' WHERE employee_id = 3536256;"
        ],
        "mysql": [
          "UPDATE employee SET bank_account_number = '{\"bank_name\": \"Bank Example\", \"account_number\": \"9876543210\", \"routing_number\": \"0123456789\"}' WHERE employee_id = 3536256;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "UPDATE",
        "JSON_SET"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0,
        "Extra context": "employee_id = 3536259"
      }
    },
    {
      "id": 191,
      "nl_prompt": "Update the coverage of a benefit with benefit_id. Add a new department coverage for \"Marketing\".",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE benefit SET coverage = coverage || '{\"department\": [\"Marketing\"]}'::jsonb WHERE benefit_id = 5;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM benefit WHERE benefit_id = 5 AND coverage = coverage || '{\"department\": [\"Marketing\"]}'::jsonb;"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM benefit WHERE benefit_id = 5;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE benefit SET coverage ='Tuition, Fees, Books' WHERE benefit_id = 5;"
        ],
        "mysql": [
          "UPDATE benefit SET coverage ='Tuition, Fees, Books' WHERE benefit_id = 5;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE benefit SET coverage ='Tuition, Fees, Books' WHERE benefit_id = 5;"
        ],
        "mysql": [
          "UPDATE benefit SET coverage ='Tuition, Fees, Books' WHERE benefit_id = 5;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE",
        "JSON_INSERT"
      ],
      "other": {
        "Extra context": "benefit_id= 5",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 192,
      "nl_prompt": "Update the materials URL of a training with training_id. Set the new materials URL.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE training SET link = 'https://example.com/new-training-materials' WHERE training_id = 108;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM training WHERE training_id = 108 AND link = 'https://example.com/new-training-materials';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM training WHERE training_id = 108 AND link = 'https://example.com/new-training-materials';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE training SET link = 'http://example.com/time-management-seminar' WHERE training_id = 108;"
        ],
        "mysql": [
          "UPDATE training SET link = 'http://example.com/time-management-seminar' WHERE training_id = 108;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE training SET link = 'http://example.com/time-management-seminar' WHERE training_id = 108;"
        ],
        "mysql": [
          "UPDATE training SET link = 'http://example.com/time-management-seminar' WHERE training_id = 108;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "training_id = 108",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 193,
      "nl_prompt": "Introduce a JSON column named benefit_usage in the employee_x_benefit table to hold additional notes related to employee benefit",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE employee_x_benefit ADD COLUMN benefit_usage JSON;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee_x_benefit' AND column_name = 'benefit_usage';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee_x_benefit' AND column_name = 'benefit_usage';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE employee_x_benefit DROP COLUMN IF EXISTS benefit_usage;"
        ],
        "mysql": [
          "ALTER TABLE employee_x_benefit DROP COLUMN benefit_usage;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE employee_x_benefit DROP COLUMN IF EXISTS benefit_usage;"
        ],
        "mysql": [
          "ALTER TABLE employee_x_benefit DROP COLUMN benefit_usage;"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "ADD_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 194,
      "nl_prompt": "Introduce a JSON column named training_notes in the employee_training table to hold additional notes related to employee training",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE employee_training ADD COLUMN training_notes JSON;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee_training' AND column_name = 'training_notes';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'employee_training' AND column_name = 'training_notes';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE employee_training DROP COLUMN IF EXISTS training_notes;"
        ],
        "mysql": [
          "ALTER TABLE employee_training DROP COLUMN training_notes;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE employee_training DROP COLUMN IF EXISTS training_notes;"
        ],
        "mysql": [
          "ALTER TABLE employee_training DROP COLUMN training_notes;"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "ADD_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 195,
      "nl_prompt": "Create a JSON column named additional_compensation in the salary table to store any additional salary -related information.",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE salary ADD COLUMN additional_compensation JSON;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'salary' AND column_name = 'additional_compensation';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'salary' AND column_name = 'additional_compensation';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE salary DROP COLUMN IF EXISTS additional_compensation;"
        ],
        "mysql": [
          "ALTER TABLE salary DROP COLUMN additional_compensation;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE salary DROP COLUMN IF EXISTS additional_compensation;"
        ],
        "mysql": [
          "ALTER TABLE salary DROP COLUMN additional_compensation;"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "ADD_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 196,
      "nl_prompt": "Create a new JSON column named additional_data in the department table to capture any additional department data.",
      "query_type": "ddl",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "ALTER TABLE department ADD COLUMN additional_data JSON;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'department' AND column_name = 'additional_data';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'department' AND column_name = 'additional_data';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "ALTER TABLE department DROP COLUMN IF EXISTS additional_data;"
        ],
        "mysql": [
          "ALTER TABLE department DROP COLUMN additional_data;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "ALTER TABLE department DROP COLUMN IF EXISTS additional_data;"
        ],
        "mysql": [
          "ALTER TABLE department DROP COLUMN additional_data;"
        ]
      },
      "tags": [
        "DDL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "ALTER",
        "ADD_COLUMN"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 197,
      "nl_prompt": "Insert benefit_usage for employee_x_benefit with employee_id and benefit_id",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee_x_benefit SET start_date ='2021-09-01' WHERE employee_id = 3536259 AND benefit_id = 9;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM employee_x_benefit WHERE employee_id = 3536259 AND benefit_id = 9 AND start_date ='202-09-01';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM employee_x_benefit WHERE employee_id = 3536259 AND benefit_id = 9 AND start_date ='202-09-01';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee_x_benefit SET start_date ='2022-09-01' WHERE employee_id = 3536259 AND benefit_id = 9;"
        ],
        "mysql": [
          "UPDATE employee_x_benefit SET start_date ='2022-09-01' WHERE employee_id = 3536259 AND benefit_id = 9"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee_x_benefit SET start_date ='2022-09-01' WHERE employee_id = 3536259 AND benefit_id = 9;"
        ],
        "mysql": [
          "UPDATE employee_x_benefit SET start_date ='2022-09-01' WHERE employee_id = 3536259 AND benefit_id = 9;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "employee_id = 3536259 AND benefit_id = 9",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 198,
      "nl_prompt": "Insert additional_data for department with department_id",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE department SET goals = '{\"goal1\": \"Recruit top talent\", \"goal2\": \"Employee development\"}' WHERE department_id = 1;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM department WHERE department_id = 1;"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM department WHERE department_id = 1;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE department SET goals = '{\"goal1\": \"Recruit top talent\", \"goal2\": \"Employee development\"}' WHERE department_id = 1;"
        ],
        "mysql": [
          "UPDATE department SET goals = '{\"goal1\": \"Recruit top talent\", \"goal2\": \"Employee development\"}' WHERE department_id = 1;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE department SET goals = '{\"goal1\": \"Recruit top talent\", \"goal2\": \"Employee development\"}' WHERE department_id = 1;"
        ],
        "mysql": [
          "UPDATE department SET goals = '{\"goal1\": \"Recruit top talent\", \"goal2\": \"Employee development\"}' WHERE department_id = 1;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "department_id = 1",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 199,
      "nl_prompt": "Insert additional_compensation for salary with salary_id",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE salary SET total_compensation = '57000.00' WHERE salary_id = 1;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) FROM salary WHERE salary_id = 1 AND total_compensation = '57000.00';"
        ],
        "mysql": [
          "SELECT COUNT(*) FROM salary WHERE salary_id = 1 AND total_compensation = '57000.00';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE salary SET total_compensation = '57000.00' WHERE salary_id = 1;"
        ],
        "mysql": [
          "UPDATE salary SET total_compensation = '57000.00' WHERE salary_id = 1;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE salary SET total_compensation = '57000.00' WHERE salary_id = 1;"
        ],
        "mysql": [
          "UPDATE salary SET total_compensation = '57000.00' WHERE salary_id = 1;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "salary_id = 1",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 200,
      "nl_prompt": "Insert training_notes for employee_training with employee_id and training_id",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres",
        "mysql"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee_training SET end_date = '2023-05-30' WHERE employee_id = 3536255 AND training_id = 105;"
        ],
        "mysql": [
          null
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT count(*) FROM employee_training WHERE employee_id = 3536255 AND training_id = 105;"
        ],
        "mysql": [
          "SELECT count(*) FROM employee_training WHERE employee_id = 3536255 AND training_id = 105;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee_training SET end_date = '2023-05-30' WHERE employee_id = 3536255 AND training_id = 105;"
        ],
        "mysql": [
          "UPDATE employee_training SET end_date = '2023-05-30' WHERE employee_id = 3536255 AND training_id = 105;"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee_training SET end_date = '2023-05-30' WHERE employee_id = 3536255 AND training_id = 105;"
        ],
        "mysql": [
          "UPDATE employee_training SET end_date = '2023-05-30' WHERE employee_id = 3536255 AND training_id = 105;"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "UPDATE"
      ],
      "other": {
        "Extra context": "employee_id = 3536255 AND training_id = 105",
        "Compare Type": "Execution result",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 201,
      "nl_prompt": "Who are the newest employees for each department to join the company and there manager?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "WITH NewestEmployees AS ( SELECT e.employee_id, e.first_name, e.last_name, e.department_id, e.manager_id, e.hire_date, ROW_NUMBER() OVER (PARTITION BY e.department_id ORDER BY e.hire_date DESC) AS rn FROM employee e ) SELECT ne.employee_id, ne.first_name, ne.last_name, ne.department_id, ne.manager_id, ne.hire_date, m.first_name AS manager_first_name, m.last_name AS manager_last_name FROM NewestEmployees ne JOIN employee m ON ne.manager_id = m.employee_id WHERE ne.rn = 1;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "JOIN",
        "RANK",
        "SORT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 202,
      "nl_prompt": "What is the average salary in the company?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT ROUND(AVG(salary),2) AS AverageSalary FROM employee e JOIN salary s ON e.employee_id = s.employee_id;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JOIN",
        "AGGREGATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 203,
      "nl_prompt": "What are the top 5 employees that have more benefits in 2022?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, COUNT(*) AS total_benefits FROM employee e JOIN employee_x_benefit xb ON e.employee_id = xb.employee_id WHERE DATE_TRUNC('year', xb.start_date) = DATE_TRUNC('year', CURRENT_DATE - INTERVAL '2' YEAR) GROUP BY e.employee_id, e.first_name, e.last_name ORDER BY total_benefits DESC LIMIT 5;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "DATE",
        "JOIN",
        "AGGREGATE",
        "SORT",
        "LIMIT"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 204,
      "nl_prompt": "How many employees are eligible for retirement within the next sixty five years?",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT COUNT(*) AS total_eligible_for_retirement FROM public.employee WHERE date_of_birth <= CURRENT_DATE - INTERVAL '30 years' AND date_of_birth >= CURRENT_DATE - INTERVAL '95 years';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result",
        "Context": "Match"
      }
    },
    {
      "id": 205,
      "nl_prompt": "List all employees who have utilized more than 3 annual leave entitlement by the current month.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, SUM(duration) FROM employee e JOIN leave_request l ON e.employee_id = l.employee_id WHERE EXTRACT(YEAR FROM l.start_date) = EXTRACT(YEAR FROM CURRENT_DATE) AND EXTRACT(MONTH FROM l.start_date) <= EXTRACT(MONTH FROM CURRENT_DATE) GROUP BY e.employee_id, e.first_name HAVING SUM(duration) >3;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN",
        "AGGREGATE",
        "HAVING",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result match",
        "Context": "Match"
      }
    },
    {
      "id": 206,
      "nl_prompt": "Retrieve all employees who have a bank account in a 'Anothertown' City from their address.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT * FROM employee WHERE address->>'city' = 'Anothertown';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JSON_EXTRACT"
      ],
      "other": {
        "Extra context": "address->>'city' = 'Anothertown'",
        "Compare Type": "Execution result match",
        "Context": "Match"
      }
    },
    {
      "id": 207,
      "nl_prompt": "List all employees who are eligible for the \"Health Insurance\" benefit.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.first_name, e.last_name FROM employee e JOIN employee_x_benefit eb ON e.employee_id = eb.employee_id JOIN benefit b ON eb.benefit_id = b.benefit_id WHERE b.benefit_name = 'Health Insurance';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "JOIN"
      ],
      "other": {
        "Extra context": "benefit_name = 'Health Insurance'",
        "Compare Type": "Execution result match",
        "Context": "Match"
      }
    },
    {
      "id": 208,
      "nl_prompt": "Identify employees with a high number of job changes in the last three years, along with their current job titles and departmental information",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.employee_id, e.first_name, e.last_name, e.email, j.job_title, d.department_name, COUNT(DISTINCT jh.job_history_id) AS job_changes FROM public.employee e JOIN public.job_history jh ON e.employee_id = jh.employee_id AND jh.start_date > CURRENT_DATE - INTERVAL '3 YEAR' JOIN public.job j ON jh.job_id = j.job_id JOIN public.department d ON j.department_id = d.department_id GROUP BY e.employee_id, e.first_name, e.last_name, e.email, j.job_title, d.department_name ORDER BY job_changes DESC;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "AGGREGATE",
        "JOIN",
        "SORT",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result match",
        "Context": "Match"
      }
    },
    {
      "id": 209,
      "nl_prompt": "Calculate the total cost of travel allowances reimbursed to employees for business trips to different locations in the last quarter, categorized by travel destination and purpose",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT et.travel_destination, et.travel_purpose, SUM(et.travel_expenses) AS total_travel_allowances FROM employee_travel et WHERE et.travel_start_date BETWEEN CURRENT_DATE - INTERVAL '3 MONTH' AND CURRENT_DATE GROUP BY et.travel_destination, et.travel_purpose;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: challenging",
        "SELECT",
        "AGGREGATE",
        "DATE"
      ],
      "other": {
        "Compare Type": "Execution result match",
        "Context": "Match"
      }
    },
    {
      "id": 210,
      "nl_prompt": "How can i Update the manager for the Sales department to employee ID 3536265.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE department SET manager_id = 3536265 WHERE department_name = 'Sales';"
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_department_count FROM department WHERE department_name = 'Sales' AND manager_id = 104;"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE department SET manager_id = 3536254 WHERE department_name = 'Sales';"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE department SET manager_id = 3536254 WHERE department_name = 'Sales';"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "department_name = 'Sales'",
        "Compare Type": "Execution result match",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 211,
      "nl_prompt": "Retrieve the average number of Personal days requested by employees in each department:",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT e.department_id, d.department_name, AVG(lr.duration) AS avg_vacation_days FROM leave_request lr JOIN employee e ON lr.employee_id = e.employee_id JOIN department d ON e.department_id = d.department_id WHERE lr.leave_type = 'Personal Leave' GROUP BY e.department_id, d.department_name"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT",
        "AGGREGATE",
        "JOIN"
      ],
      "other": {
        "Compare Type": "Execution result match",
        "Context": "Match"
      }
    },
    {
      "id": 212,
      "nl_prompt": "Retrieve employees who have skills in either mrketingh or selenium.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT employee_id, first_name, last_name FROM employee WHERE job_id IN ( SELECT job_id FROM job WHERE to_jsonb(skills_preferred)::text ILIKE '%Mark%' );"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "SELECT"
      ],
      "other": {
        "Compare Type": "Execution result match",
        "Context": "Match"
      }
    },
    {
      "id": 213,
      "nl_prompt": "Update the benefits coverage for employees who have recently completed 'Software Development Best Practices' training programs.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee_x_benefit SET end_date = '2024-12-31' WHERE employee_id IN ( SELECT employee_id FROM employee_training WHERE training_id IN ( SELECT training_id FROM training WHERE title = 'Software Development Best Practices' ) );"
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_benefit_rows FROM employee_x_benefit WHERE employee_id IN ( SELECT employee_id FROM employee_training WHERE training_id IN ( SELECT training_id FROM training WHERE title = 'Software Development Best Practices' ) );"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee_x_benefit SET end_date = '2022-12-31' WHERE employee_id IN ( SELECT employee_id FROM employee_training WHERE training_id IN ( SELECT training_id FROM training WHERE title = 'Software Development Best Practices' ) );"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee_x_benefit SET end_date = '2022-12-31' WHERE employee_id IN ( SELECT employee_id FROM employee_training WHERE training_id IN ( SELECT training_id FROM training WHERE title = 'Software Development Best Practices' ) );"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: moderate",
        "UPDATE",
        "SELECT"
      ],
      "other": {
        "Extra context": "title= 'Software Development Best Practices'",
        "Compare Type": "Execution result match",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 214,
      "nl_prompt": "Update the hire date of the benefit coverage for employees with certifications from a 'Project Management Institute' issuing organization.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE employee SET hire_date = '2025-01-01' WHERE employee_id IN ( SELECT ec.employee_id FROM employee_certification ec WHERE ec.issuing_organization = 'Project Management Institute' );"
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_coverage_rows FROM employee WHERE employee_id IN ( SELECT ec.employee_id FROM employee_certification ec WHERE ec.issuing_organization = 'Project Management Institute' );"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE employee SET hire_date = '2023-02-28' WHERE employee_id IN ( SELECT ec.employee_id FROM employee_certification ec WHERE ec.issuing_organization = 'Project Management Institute' );"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE employee SET hire_date = '2023-02-28' WHERE employee_id IN ( SELECT ec.employee_id FROM employee_certification ec WHERE ec.issuing_organization = 'Project Management Institute' );"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE",
        "SELECT"
      ],
      "other": {
        "Extra context": "issuing_organization = 'Project Management Institute'",
        "Compare Type": "Execution result match",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 215,
      "nl_prompt": "Update the budget of the HR department to $120000 and change the manager to employee with ID 3536265.",
      "query_type": "dml",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "UPDATE department SET budget = 120000, manager_id = 3536265 WHERE department_name = 'Human Resources';"
        ]
      },
      "eval_query": {
        "postgres": [
          "SELECT COUNT(*) AS updated_department_rows FROM department WHERE department_name = 'Human Resources';"
        ]
      },
      "setup_sql": {
        "postgres": [
          "UPDATE department SET budget = '100000.00', manager_id = '3536251' WHERE department_name = 'Human Resources';"
        ]
      },
      "cleanup_sql": {
        "postgres": [
          "UPDATE department SET budget = '100000.00', manager_id = '3536251' WHERE department_name = 'Human Resources';"
        ]
      },
      "tags": [
        "DML",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "UPDATE"
      ],
      "other": {
        "Extra context": "department_name = 'Human Resources'",
        "Compare Type": "Execution result match",
        "Context": "Match",
        "Eval response": 1.0
      }
    },
    {
      "id": 216,
      "nl_prompt": "Retrieve the address details (street, city, state, zip code) for a 3536258 employee.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT address->>'street' AS street, address->>'city' AS city, address->>'state' AS state, address->>'zip_code' AS zip_code FROM employee WHERE employee_id = 3536259;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "JSON"
      ],
      "other": {
        "Extra context": "employee_id = 3536258",
        "Compare Type": "Execution result match",
        "Context": "Match"
      }
    },
    {
      "id": 217,
      "nl_prompt": "Retrieve the names of employees who live in a Newtown city.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT first_name, last_name, address FROM employee WHERE address->>'city' = 'Newtown';"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT"
      ],
      "other": {
        "Compare Type": "Execution result match",
        "Context": "Match"
      }
    },
    {
      "id": 218,
      "nl_prompt": "Rank departments based on their budget in increasing order.",
      "query_type": "dql",
      "database": "db_hr",
      "dialects": [
        "postgres"
      ],
      "golden_sql": {
        "postgres": [
          "SELECT department_id, department_name, budget, RANK() OVER (ORDER BY budget) AS budget_rank FROM department;"
        ]
      },
      "eval_query": {
        "postgres": [
          null
        ]
      },
      "setup_sql": {},
      "cleanup_sql": {},
      "tags": [
        "DQL",
        "experience: Generation",
        "cuj: query",
        "difficulty: simple",
        "SELECT",
        "RANK"
      ],
      "other": {
        "Compare Type": "Execution result match",
        "Context": "Match"
      }
    }
  ]